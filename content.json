{"meta":{"title":"QiaoDing Blog","subtitle":"前端小学生","description":null,"author":"乔丁","url":"https://qiaoding18.github.io"},"pages":[{"title":"记录一些小问题","date":"2018-10-12T04:34:00.000Z","updated":"2018-10-12T03:58:28.749Z","comments":true,"path":"help/index.html","permalink":"https://qiaoding18.github.io/help/index.html","excerpt":"","text":"Q：我在哪？ 西安邮电大学 移动应用开发(3G)实验室 Q：我之前呢？ 西电科大附中 - 西工大初中 - 西工大附小 - 西工大幼稚园 Q：这个是干啥用的？ 装逼 Q：你做什么 会一些前端，Vue.js用的比较多 Q：给你100W想干什么 摇的上号就付首付，摇不上就捐给实验室 以上纯属胡说八道"},{"title":"标签云","date":"2018-10-12T04:37:12.000Z","updated":"2018-10-13T06:24:56.088Z","comments":true,"path":"tags/index.html","permalink":"https://qiaoding18.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP/2","slug":"http","date":"2018-06-20T04:12:12.000Z","updated":"2018-06-24T14:26:54.000Z","comments":true,"path":"2018/06/20/http/","link":"","permalink":"https://qiaoding18.github.io/2018/06/20/http/","excerpt":"","text":"首先不是HTTP/1.x的重写HTTP/2基于SPDY3，专注于性能，最大的目标实在用户和网站之间只用一个连接 SPDY SPeeDY Google开发基于TCP的应用层协议。用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64% 单个TCP连接支持并发的HTTP请求。 压缩报头和去掉不必要的头部来减少当前HTTP使用的带宽。 定义一个容易实现，在服务器端高效率的协议。通过减少边缘情况、定义易解析的消息格式来减少HTTP的复杂性。 强制使用SSL，让SSL协议在现存的网络设施下有更好的安全性和兼容性。 允许服务器在需要时发起对客户端的连接并推送数据。 所以HTTP/2和HTTPS是包含关系 SPDY原理强制使用了SSL，在SSL层上增加一个SPDY会话层，以在一个TCP连接中实现并发流通常的HTTP get和post格式仍是一样的，然而SPDY为编码和传输数据设计了一个新的帧格式 SPDY基本特征复用流：SPDY允许在一个连接上无限制并发流。因为请求在一个通道上，TCP效率更高；更少的网络连接，发出更少更密集的数据包请求优先级：虽然无限的并发流解决了序列化的问题，但如果带宽通道受限制，客户端可能会因防止阻塞通道而阻止请求。SPDY实行请求优先级：客户端从服务器端请求它希望的项目数量，并为每个请求分配一个优先级。这可以防止在网络通道被非关键资源堵塞时，高优先级的请求被挂起HTTP报头压缩：SPDY压缩请求和响应HTTP报头，从而减少传输的数据包数量和字节数 SPDY高级特征服务器启动流：能分发内容到客户端，不需要客户端发起请求。此选项可以由Web开发人员通过如下两种方式配置：1、Server push：SPDY通过X-Associated-Content头试验了服务器推送数据给客户端的选项。这个头告诉客户端服务器将在客户端请求资源之前，推送资源给它。对于初始页面下载（例如用户初次访问这个网站），这样能大大提升用户体验。2、Server hint：相对于自动推送资源到客户端，在服务器事先知道客户端需要的资源的情况下，服务器使用X-Subresources头建议客户端请求特殊的资源。但是，服务器仍然在发送内容前等待客户请求。通过窄带，这个选项能减少一个客户端发现它所需要的资源的数百毫秒，可能更适合于非初始页面加载。 SPDY并不用于取代HTTP/1.x，它只是修改了HTTP/1.x的请求与应答在网络上传输的方式；这意味着只需增加一个SPDY传输层，现有的所有服务端应用均不用做任何修改。 当使用SPDY的方式传输，HTTP请求会被处理、标记简化和压缩。比如，每一个SPDY端点会持续跟踪每一个在之前的请求中已经发送的HTTP报文头部，从而避免重复发送还未改变的头部。而还未发送的报文的数据部分将在被压缩后被发送 SPDY协议已被HTTP/2协议取代 新时代新气象影响HTTP请求的因素主要是：带宽和延迟。在当今网络情况下，带宽一般不在是瓶颈，所以主要讨论延迟。延迟造成的原因：1、浏览器线头阻塞：浏览器会因为一些原因阻塞请求2、DNS查询浪费时间3、建立连接：HTTP基于TCP协议，TCP的三次握手和慢启动极大增加延迟 HTTP/1.x中存在的问题1、连接无法复用：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响大HTTP/1.0传输数据时，每次都需要重新建立连接，增加延迟HTTP/1.1虽然加入keep-alive，可以复用一部分连接，但域名分片等情况下仍需要建立多个connetion，耗费资源，给服务器带来了性能压力2、线头阻塞：导致带宽无法被充分利用，以及后续健康请求被阻塞。HOLB是指在HTTP/1.x中，由于服务器必须按接受请求的顺序发送响应的规则限制，那么假设浏览器在一个（tcp）连接上发送两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个响应——HOLB。虽然现在浏览器允许每个origin建立6个connection，但大量网页需要上百个资源，HOLB依然是主要问题3、协议开销打：HTTP/1.x中header内容过大，但基本每次请求header基本不变化，增加了传输的成本4、安全因素：在HTTP中传输的内容都是明文，客户端和服务端双方无法验证身份。","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"oh-my-zsh","slug":"oh-my-zsh","date":"2018-06-20T04:12:12.000Z","updated":"2018-06-20T04:50:30.000Z","comments":true,"path":"2018/06/20/oh-my-zsh/","link":"","permalink":"https://qiaoding18.github.io/2018/06/20/oh-my-zsh/","excerpt":"","text":"干啥的工具bash升级版 支持多种命令这里小结一下在git命令方面的简写命令脚本文件的目录在plugins/git/git.plugin.zsh alias g=’git’ ok常用的alias gb=’git branch’ ————branchalias gco=’git checkout’ ————checkout alias gl=’git pull’ ————pull alias gm=’git merge’ ————merge alias ga=’git add’ ————addalias gcmsg=’git commit -m’ ————commitalias gp=’git push’ ————push git addalias ga=’git add’alias gaa=’git add –all’alias gapa=’git add –patch’alias gau=’git add –update’alias gap=’git apply’ git branchalias gb=’git branch’alias gba=’git branch -a’alias gbd=’git branch -d’alias gbda=’git branch –no-color –merged | command grep -vE “^(*|\\s(master|develop|dev)\\s$)” | command xargs -n 1 git branch -d’alias gbl=’git blame -b -w’alias gbnm=’git branch –no-merged’alias gbr=’git branch –remote’alias gbs=’git bisect’alias gbsb=’git bisect bad’alias gbsg=’git bisect good’alias gbsr=’git bisect reset’alias gbss=’git bisect start’ git commitalias gc=’git commit -v’alias gc!=’git commit -v –amend’alias gcn!=’git commit -v –no-edit –amend’alias gca=’git commit -v -a’alias gca!=’git commit -v -a –amend’alias gcan!=’git commit -v -a –no-edit –amend’alias gcans!=’git commit -v -a -s –no-edit –amend’alias gcam=’git commit -a -m’alias gcsm=’git commit -s -m’alias gcf=’git config –list’alias gcl=’git clone –recursive’alias gclean=’git clean -fd’alias gpristine=’git reset –hard &amp;&amp; git clean -dfx’alias gcmsg=’git commit -m’ git checkoutalias gco=’git checkout’alias gcb=’git checkout -b’alias gcm=’git checkout master’alias gcd=’git checkout develop’alias gcount=’git shortlog -sn’alias gcp=’git cherry-pick’alias gcpa=’git cherry-pick –abort’alias gcpc=’git cherry-pick –continue’alias gcs=’git commit -S’ git diffalias gd=’git diff’alias gdca=’git diff –cached’alias gdcw=’git diff –cached –word-diff’alias gdct=’git describe –tags git rev-list --tags --max-count=1‘alias gdt=’git diff-tree –no-commit-id –name-only -r’alias gdw=’git diff –word-diff’ git fetchalias gf=’git fetch’alias gfa=’git fetch –all –prune’alias gfo=’git fetch origin’ git gui citoolalias gg=’git gui citool’alias gga=’git gui citool –amend’ git pullalias gl=’git pull’alias gunignore=’git update-index –no-assume-unchanged’alias gunwip=’git log -n 1 | grep -q -c “--wip--“ &amp;&amp; git reset HEAD~1’alias gup=’git pull –rebase’alias gupv=’git pull –rebase -v’alias glum=’git pull upstream master’ git logalias glg=’git log –stat’alias glgp=’git log –stat -p’alias glgg=’git log –graph’alias glgga=’git log –graph –decorate –all’alias glgm=’git log –graph –max-count=10’alias glo=’git log –oneline –decorate’alias glol=”git log –graph –pretty=’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’”alias glod=”git log –graph –pretty=’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset’”alias glods=”git log –graph –pretty=’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset’ –date=short”alias glola=”git log –graph –pretty=’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –all”alias glog=’git log –oneline –decorate –graph’alias gloga=’git log –oneline –decorate –graph –all’alias glp=”_git_log_prettily” git mergealias gm=’git merge’alias gmom=’git merge origin/master’alias gmt=’git mergetool –no-prompt’alias gmtvim=’git mergetool –no-prompt –tool=vimdiff’alias gmum=’git merge upstream/master’alias gma=’git merge –abort’ git pushalias gp=’git push’alias gpd=’git push –dry-run’alias gpoat=’git push origin –all &amp;&amp; git push origin –tags’compdef _git gpoat=git-pushalias gpu=’git push upstream’alias gpv=’git push -v’ git remotealias gr=’git remote’alias gra=’git remote add’alias grb=’git rebase’alias grba=’git rebase –abort’alias grbc=’git rebase –continue’alias grbi=’git rebase -i’alias grbm=’git rebase master’alias grbs=’git rebase –skip’alias grh=’git reset HEAD’alias grhh=’git reset HEAD –hard’alias grmv=’git remote rename’alias grrm=’git remote remove’alias grset=’git remote set-url’alias grt=’cd $(git rev-parse –show-toplevel || echo “.”)’alias gru=’git reset –’alias grup=’git remote update’alias grv=’git remote -v’ git statusalias gsb=’git status -sb’alias gsd=’git svn dcommit’alias gsi=’git submodule init’alias gsps=’git show –pretty=short –show-signature’alias gsr=’git svn rebase’alias gss=’git status -s’alias gst=’git status’alias gsta=’git stash save’alias gstaa=’git stash apply’alias gstc=’git stash clear’alias gstd=’git stash drop’alias gstl=’git stash list’alias gstp=’git stash pop’alias gsts=’git stash show –text’alias gsu=’git submodule update’ git tagalias gts=’git tag -s’alias gtv=’git tag | sort -V’","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"Vue中sync前世今生","slug":"Vue里sync","date":"2018-05-27T04:12:12.000Z","updated":"2018-05-27T05:32:52.000Z","comments":true,"path":"2018/05/27/Vue里sync/","link":"","permalink":"https://qiaoding18.github.io/2018/05/27/Vue里sync/","excerpt":"","text":"Vue 1.x 里在Vue 1.x版本中，强大的sync控制的数据使父组件的变量被子组件随意修改 123456789101112131415161718192021222324252627282930&lt;div id=\"father\"&gt; &lt;child :need-msg.sync=\"msg\"&gt;&lt;/child&gt; &lt;button @click=\"changeNeed\"&gt;加加加&lt;/button&gt;&lt;/div&gt;&lt;script&gt;Vue.component('child', &#123; template:`&lt;div&gt; &lt;p&gt;&#123;&#123; needMsg &#125;&#125;&lt;/p&gt; &lt;button @click.stop=\"reduceNeed\"&gt;减减减 &lt;/button&gt; &lt;/div&gt;`, props: ['needMsg'], methods: &#123; reduceNeed () &#123; this.needMsg--; this.$emit('update:needMsg', this.needMsg); &#125; &#125;,&#125;);new Vue(&#123; el: '#father', data: &#123; msg: 1 &#125;, methods: &#123; changeNeed () &#123; this.msg++; &#125; &#125;&#125;)&lt;/script&gt; 父组件控制加，子组件控制减。只需要加上sync就可以实现双向数据流 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。 于是在Vue 2.0开始取消了sync的使用 在使用sync时会有报错[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “needMsg”(found in \\) 报错意思是父组件再去修改prop值会导致覆盖 Vue 2.0 开始父组件依然可以通过prop向子组件传递值，但是子组件对于值的修改将不会直接影响到父组件。sync消失后取而代之的是$emmit和$on这样通过自定义事件在父组件监听子组件的变动这样依然可以实现双向数据绑定的效果，同时将子组件、父组件状态的代码区分sync再见吧 Vue 2.3 重出江湖在父组件监听时需要这样写12v-bind:title=\"doc.title\"v-on:update:title=\"doc.title = $event\" 为了解决这种复杂的写法，同时为了方便Vue 1.x升级时不用做大量的代码修改，在Vue 2.3版本重新复出了sync，这次的sync只是一个语法糖，用来取代在父组件监听时如上复杂的写法 同时也要注意将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Vue 1.x升级相关问题2.0","slug":"Vue1x版本升级小结","date":"2018-05-25T00:32:00.000Z","updated":"2018-05-25T01:35:56.000Z","comments":true,"path":"2018/05/25/Vue1x版本升级小结/","link":"","permalink":"https://qiaoding18.github.io/2018/05/25/Vue1x版本升级小结/","excerpt":"","text":"在升级Vue 1.x项目时遇到了很多情况，小结一下 工具vue-migration-helper在运行了vue-migration-helper之后会提供一些升级信息，根据提示信息修改相应代码 总结一下改动比较多的地方 双向数据绑定Replace :xxx.sync=&quot;ooo&quot; with :visible=&quot;ooo&quot;, then $emit an event from the child component to trigger an update to xxx in the parent在Vue 2.3以下版本中，数据流被限制，取消了sync，来解决父组件受到子组件不必要的影响的问题。解决的办法就是使用自定义事件向父组件传参Vue 2.3中sync配合v-bind使用，被扩展成为一个自动更新父组件属性的v-on监听器 生命周期 主要的ready向mounted这两个钩子函数的转变。1.x中的compiled感觉意义并不大 transitionVue 2.x中废弃掉了之前的transition属性，使用transition标签，并指定name属性实现效果 而且在Vue 2.x中的transition的钩子函数可以在methods中调用，废弃了之前的全局Vue.transition方法1234567891011121314151617181920// Vue 1.xVue.transition('xxx', &#123; beforeEnter: function( )&#123; ... &#125;, enter: function( )&#123; ... &#125; ...&#125;)// Vue 2.xmethods: &#123; beforeEnter( )&#123; ... &#125; enter( )&#123; ... &#125; ...&#125; 过滤器在Vue 2.x中不再提供内置过滤器，需要引入外部库，比如moment.js来计算时间12345// Vue 1.x&lt;div&gt;&#123;&#123; item.appDate | date 'yyyy-MM-dd' &#125;&#125;&lt;/div&gt;// Vue 2.x&lt;div&gt;&#123;&#123; item.appDate | date('yyyy-MM-dd') &#125;&#125;&lt;/div&gt; Vue Router router.go() 改为 router.push() router.map()被routes数组取代 router-link 改为 v-link route.refresh 改为 route.meta.refresh 其他改动 v-for中废弃了$index { { { xxoo } } } 改为 v-html v-el 和 v-ref 合并成ref属性","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"istanbul是个啥","slug":"istanbul","date":"2018-05-23T02:32:00.000Z","updated":"2018-05-22T06:43:34.000Z","comments":true,"path":"2018/05/23/istanbul/","link":"","permalink":"https://qiaoding18.github.io/2018/05/23/istanbul/","excerpt":"","text":"balabala要学的真的是多 组里氛围很棒 压力甚大 正题对于是否所有代码都测试到了有个指标，代码覆盖率。有四个测量维度 行覆盖率（line coverage）：是否每一行都执行了函数覆盖率（function coverage）：是否每个函数都调用了分支覆盖率（branch coverage）：是否每个if代码块都执行了语句覆盖率（statement coverage）：是否每个语句都执行了 Istanbul是js代码覆盖率的计算工具这个软件以土耳其最大城市伊斯坦布尔命名，因为土耳其地毯世界闻名，而地毯是用来覆盖的。 exp123456789let a = 6;let b = 6;if(a &gt; b)&#123; console.log('a &gt; b')&#125;else if(a &lt; b)&#123; console.log('a &lt; b')&#125;else&#123; console.log('a = b')&#125; 123456============= Coverage summary =================Statements : 71.43% ( 5/7 )Branches : 50% ( 2/4 )Functions : 100% ( 0/0 )Lines : 71.43% ( 5/7 )================================================ 返回显示的：7个语句执行5个4个分支执行了2个0个函数执行了0个7行代码执行了5行 还剩成了coverage这个子目录，可以可视化的看情况 这个工具还可以设置覆盖率门槛还可以与其他测试框架结合 忽略代码在vue源码中用到的是istanbul的注释语法，允许某些代码不计入覆盖率1var object = parameter || /* istanbul ignore next * / &#123;&#125;; 上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。 1234/* istanbul ignore if */if (a)) &#123; return callback(b);&#125; 上面代码的if语句块，在计算覆盖率的时候会被忽略","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"Vue的slot内容分发","slug":"Vue的slot内容分发","date":"2018-05-23T02:11:09.000Z","updated":"2018-05-22T02:19:44.000Z","comments":true,"path":"2018/05/23/Vue的slot内容分发/","link":"","permalink":"https://qiaoding18.github.io/2018/05/23/Vue的slot内容分发/","excerpt":"","text":"概述假如父组件需要在字组件内放一些DOM，那么这些DOM是显示、不显示、在哪显示、如何显示，就是由slot分发负责 默认情况下父组件在子组件内直接写的的内容，是不显示的12345678910111213141516&lt;div id=\"app\"&gt; &lt;children&gt; &lt;span&gt;3g666&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;button&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 显示一个button，不包含span标签里面的内容 单个slot简单来说，只使用这个标签，可以将父组件放在子组件的内容，放到让他显示的地方12345678910111213141516&lt;div id=\"app\"&gt; &lt;children&gt; &lt;span&gt;3g666&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;button&gt;&lt;slot&gt;&lt;/slot&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 这样的结果就是&lt; button&gt;&lt; span&gt;12345&lt; / span&gt;为了明确作用范围，所以使用button标签&lt; / button&gt;即父组件放在字组件里的内容，插到了子组件的&lt; slot&gt;&lt; / slot&gt;位置注意，即便有多个标签，会一起被插入，相当于用父组件放在子组件里的标签，替换了&lt; slot&gt;&lt; / slot&gt;这个标签 具名slot将放在子组件里的不同html标签放在不同的位置父组件在要分发的标签里添加slot=’name名’属性子组件在对应分发的位置的slot标签里，添加name=’name名’属性然后就会将对应的标签放在对应的位置1234567891011121314151617&lt;div id=\"app\"&gt; &lt;children&gt; &lt;span slot=\"first\"&gt;12345&lt;/span&gt; &lt;span slot=\"second\"&gt;56789&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;button&gt;&lt;slot name='first'&gt;&lt;/slot&gt;为了明确作用范围，&lt;slot name='second'&gt;&lt;/slot&gt;所以使用button标签&lt;/button&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 显示结果：&lt; button&gt;&lt; span slot=”first”&gt;12345&lt; / span&gt;为了明确作用范围，&lt; span slot=”second”&gt;56789&lt; / span&gt;所以使用button标签&lt; / button&gt; 分发内容的作用域被分发的内容的作用域，根据其所在模板决定，以上标签，在其父组件模板中，虽然其被子组件的children标签所包括，但由于他不再子组件的template属性中，因此不属于子组件，还是受父组件的控制12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;children&gt; &lt;span slot=\"first\" @click=\"tobeknow\"&gt;12345&lt;/span&gt; &lt;span slot=\"second\"&gt;56789&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; tobeknow: function () &#123; console.log(\"It is the parent's method\"); &#125; &#125;, components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;button&gt;&lt;slot name='first'&gt;&lt;/slot&gt;为了明确作用范围，&lt;slot name='second'&gt;&lt;/slot&gt;所以使用button标签&lt;/button&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 这个只有在点击文字12345时候，才会触发父组件的tobeknow但是点击其他地方则没有影响 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译 当没有分发内容时的提示加入父组件没有子组件中放置有标签，或者是父组件在子组件中防止标签，但是有slot属性，而子组件中没有该slot属性的标签那么子组件的slot就会失效没用除非该slot标签内有内容，那么在无分发内容的时候，会显示该slot标签内的内容12345678910111213141516&lt;div id=\"app\"&gt; &lt;children&gt; &lt;span slot=\"first\"&gt;【12345】&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;div&gt;&lt;slot name='first'&gt;&lt;button&gt;【如果没有内容则显示我1】&lt;/button&gt;&lt;/slot&gt;为了明确作用范围，&lt;slot name='last'&gt;&lt;button&gt;【如果没有内容则显示我2】&lt;/button&gt;&lt;/slot&gt;所以使用button标签&lt;/div&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 第一个slot因为父组件有对应的标签会被替换，第二个父组件中没用对应的slot标签，会直接显示slot中的内容 加入想控制子组件根标签的属性1、由于模板标签是属于父组件的，因此，将子组件的指令绑定在模板标签里，是不可以的，他终归还是属于父组件2、加入需要通过父组件控制子组件是否显示，比如v-if，v-show，那么这个指令显然是属于父组件的（例如放在父组件的data下面）可以将标签卸载子组件的模板上1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;button @click=\"toshow\"&gt;点击让子组件显示&lt;/button&gt; &lt;children v-if=\"abc\"&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; abc: false &#125;, methods: &#123; toshow: function () &#123; this.abc = !this.abc; &#125; &#125;, components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;div&gt;这里是子组件&lt;/div&gt;\" &#125; &#125; &#125;); &lt;/script&gt; 说明：通过父组件（点击按钮，切换v-if指令的值）控制子组件是否显示3、假如需要通过子组件是否显示，比如是否让他隐藏，那么这个指令显然是属于子组件的，这个控制显示的值应该放在子组件的data属性下，那么就不能像上面这么写，而是必须防止在子组件的根标签中。1234567891011121314151617181920212223242526272829303132&lt;div id=\"app\"&gt; &lt;button @click=\"toshow\"&gt;点击让子组件显示&lt;/button&gt; &lt;children&gt; &lt;span slot=\"first\"&gt;【12345】&lt;/span&gt; &lt;!--上面这行不会显示--&gt; &lt;/children&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; toshow: function () &#123; this.$children[0].tohidden = true; &#125; &#125;, components: &#123; children: &#123; //这个无返回值，不会继续派发 template: \"&lt;div v-if='tohidden' @click='tohide'&gt;这里是子组件&lt;/div&gt;\", data: function () &#123; return &#123; tohidden: true &#125; &#125;, methods: &#123; tohide: function () &#123; this.tohidden = !this.tohidden; &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 这样，点击子组件会让子组件消失点击父组件的按钮，通过更改子组件的控制隐藏的data属性，让子组件重新显示子组件的指令绑定在子组件的模板之中","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"flow.js","slug":"flowjs","date":"2018-05-22T11:31:00.000Z","updated":"2018-05-21T13:06:32.000Z","comments":true,"path":"2018/05/22/flowjs/","link":"","permalink":"https://qiaoding18.github.io/2018/05/22/flowjs/","excerpt":"","text":"balabalajs对于类型检测不是很好，很难保证一些变量和函数和预期的一样flow.js是facebook出品，它的的类型系统可以保证代码的可靠性，在后期维护的时候能够传达出有效的信息要在js前的注释里写上 //@flowgit文档 简单类型flow.js中定义了5种最简单的类型，都是小写，其中void对应js的undefined * boolean * number * string * null * void just like this12var num:number = 1;var str:string = 'a'; 复杂类型主要有 * Object * Array * 函数 * 自定义Class exp： 对象123456789//Object大写的Ovar o:Object = &#123; hello:'h'&#125;;//声明了Object的keyvar o2:&#123;key:string&#125; = &#123; key:'z233'&#125;; 数组123456789//基于基本类似的数组，数组内都是相同类型var numberArr:number[] = [12,3,4,5,2];//另一个写法var numberAr2r:Array&lt;number&gt; = [12,3,2,3];var stringArr:string[] = ['12','a','cc'];var booleanArr:boolean[] = [true,true,false];var nullArr:null[] = [null,null,null];var voidArr:void[] = [ , , undefined,void(0)]; 函数12345678910111213141516171819202122232425262728293031323334/** * 声明带类型的函数 * 这里是声明一个函数fn，规定了自己需要的参数类型和返回值类型。 */function fn(arg:number,arg2:string):Object&#123; return &#123; arg, arg2 &#125;&#125;//同理，ES2015箭头函数的写法var fn2 = (arg:number,arg2:string):Object =&gt; &#123; return &#123; arg, arg2 &#125;&#125;/** * 这里是声明变量fn2，规定了它所需的函数的特征: * 参数： (arg:string,arg2:number) * 返回值：Object */var fn3:(arg:string,arg2:number)=&gt;Object = function()&#123; return &#123;&#125;&#125;/** * 对比下面这种写法, * 两者的声明的地方不一样，造成的意义也不同。 */var fn4 = function(arg:string,arg2:Object):number&#123; return 1;&#125; 自定义class12345678class MyClass&#123; name:string; constructor(n)&#123; this.name = n; &#125;&#125;var myClass : MyClass = new MyClass('abc'); 引入如果是正经的带webpack + babel 的前端项目,可以无缝集成，加入babel插件即可：babel-plugin-transform-flow-strip-types 个人觉得flow解决了代码在封装时候对于参数未知的情况的处理问题，嗯","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"vue编译","slug":"vue编译","date":"2018-05-21T08:18:21.000Z","updated":"2018-05-21T08:18:52.000Z","comments":true,"path":"2018/05/21/vue编译/","link":"","permalink":"https://qiaoding18.github.io/2018/05/21/vue编译/","excerpt":"","text":"vue使用虚拟DOM作为view层，render方法返回一个vdom结构，compiler的作用就是将template编译成render 编译parser：将template字符串解析为html语法树，并且根据parse的平台相关的modules对语法树中的节点进行修改optimizer：遍历语法树，发现static静态部分，将其变为常量(存储为静态引用)，这样在更新vdom树时，可以迅速跳过他们codegen：根据语法树，生成render和staticRenderFns函数 parserparse调用html-parser，传入start，end，chars，comments等选项，在html-parser解析到相应位置进行处理start：标签开始，传入tag，attrs，unary，执行preTransformNode，postTransformNode两个钩子函数，还对attrs进行处理，比如对于attrs中包含的v-for属性进行v-for语句验证，以及解析v-for语句中的iterator的名字end：标识一个标签结果，管理堆栈状态chars：标签的textContent部分，判断是否可以裁剪，解析绑定。比如hello 解析为‘hello’ + ——s(person.name)，这样在后面生成代码阶段可以直接赋予text参数(VNode(tag, data, children, text))。_s为VDom helpers，将其参数转化为字符串comments：插入comment类型的节点 optimizeroptimizer旨在为树的节点标上static和staticRoot属性 遍历一轮，标记static属性： 1、判断node是否为static 2、标记node的children是否为static，若存在nonstatic子节点，父节点更改为static = false 遍历二轮，标记staticRoot 1、标记static活节点为staticRoot，这个节点type === 1 （一般是含有tag属性的节点） 2、具有v-once指令的节点同样被标记为staticRoot 3、为了避免过度优化，只有static text为子节点的节点不被标记为staticRoot 4、标记节点children的staticRoot codegen代码生成器的逻辑没有想象中那么复杂，里面逻辑很多，但是非常清楚对于v-for标记的vnode1234567891011121314function getFor(el, state, altGen, altHelper) &#123; // ... return `$&#123;altHelper || '_l'&#125;(($&#123;exp&#125;),` + `function($&#123;alias&#125;$&#123;iterator1&#125;$&#123;iterator2&#125;)&#123;` + `return $&#123;(altGen || genElement)(el, state)&#125;` + '&#125;)'&#125;// core/instance/render-helpers/render-list.jsfunction renderList(val, render) &#123; // v-for的exp可以传手写数组，字符串，number，或vm.$data数据 // 根据exp自动生成vnode数组&#125; _ altHelper为ssr所用，browser端使用_l helper，但是ssr会使用ssrList helper Vue的v-for非常灵活，使用极其方便，从这里可以看到Vue的codegen为了做了非常多的工作，让我们摆脱了许多脏活。 events生成codegen中对于事件代码处理同样精彩。只需要一个@click.prevent=”onClick”，Vue变为我们写出$event.stopPropagation，如果是@click = “show = !show”，Vue还会自动编写包装show = !show函数。 events中有两个不熟的知识： passive标识 passive event listeners，passive有助于提高滚动流畅度。touch事件默认行为是滚动页面，绑定touch事件回调可以阻止默认滚动行为，没有passive选项，浏览器需要等待touch事件回调是否调用了event.preventDefault来决定它是否应该做出滚动行为，有passive选项，浏览器则不理会有没有event.preventDefault，直接滚动。 passive在parser中被解析处理，Vue支持passive的modifier event.composing 出现在platforms/web/runtime/directives/model，搜索关于event.composing的资料，正好是yyx大神的博客DOM COMPOSITION EVENTS COMPATIBILITY NOTES。event.composing代表输入法输入状态，用event.composing做guarding，可以避免输入触发input事件。 在渲染函数被调用的时候。一系列带下划线的VNode生成函数会调用VNode的函数，设置其属性并通过children记录其子VNode节点，从而形成一个VNode树12345678910111213141516171819202122232425function anonymous() &#123; // this 指向当前 Vue 实例, 这样 todos, completed 才能指向 Vue 实例属性 with (this) &#123; return _c( 'div', &#123; attrs: &#123; \"id\": \"root\" &#125; &#125;, [ _c('h1', &#123; staticClass: \"todo-list\" &#125;, [ _v(\"Here's something to do\") ]), _v(\" \"), _c('ul', _l((todos), function (todo) &#123; return _c('li', [_v(_s(todo))]) &#125;)), _v(\" \"), (completed) ? _c('p', [_v(\"Completed!\")]) : _c('p', [_v(\"Not completed...\")]) ] ) &#125;&#125; _ c定义在 core/instance/render中，用来构造元素节点1vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) createElement 较为重要, 它最经常被调用, 还要负责维护 VNode 之间的父子关系. _ v用来构造文本节点123export function createTextVNode(val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val))&#125; _ l用来构造列表节点, 它的参数是一个数组和一个用于生成数组成员节点的回调函数.1234567891011121314151617181920212223242526272829303132export function renderList( val: any, render: ( val: any, keyOrIndex: string | number, index?: number ) =&gt; VNode): ?Array&lt;VNode&gt; &#123; let ret: ?Array&lt;VNode&gt;, i, l, keys, key if (Array.isArray(val) || typeof val === 'string') &#123; ret = new Array(val.length) for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i) &#125; &#125; else if (typeof val === 'number') &#123; ret = new Array(val) for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i) &#125; &#125; else if (isObject(val)) &#123; keys = Object.keys(val) ret = new Array(keys.length) for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i] ret[i] = render(val[key], key, i) &#125; &#125; if (isDef(ret)) &#123; ret._isVList = true &#125; return ret&#125; 可以看到 v-if 并没有对应的函数, 我们可以从渲染函数中看到它是靠若干个三元组实现的. 当渲染函数执行完毕之后, VNode 树就构造好了, 并被交给 _ update 方法.","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"vue1x升级相关问题","slug":"vue1x升级相关问题","date":"2018-05-20T05:20:06.000Z","updated":"2018-10-13T07:16:02.686Z","comments":true,"path":"2018/05/20/vue1x升级相关问题/","link":"","permalink":"https://qiaoding18.github.io/2018/05/20/vue1x升级相关问题/","excerpt":"","text":"== 升级1x问题汇总 ==1 twoway 双向绑定问题2 生命周期ready替换为mounted3 stylus和指令有关系？4 v-bind 代替 { { } }5 ref 代替 v-ref6 sync问题 $emit解决 （未解决）7 v-for ()中value和index的顺序反转8 vue transition 升级 用钩子函数https://segmentfault.com/q/10100000077385009 这个没明白￼refactor number to a v-model modifier: v-model.number=”xx”￼10 路由的钩子函数升级 activate 升级为 beforeRouteEnter11 未解决￼check vue.directive(‘xxx’) to make sure its syntax has been update and for anything beyond simple DOM manipulations12 计算属性的缓存验证被移除了https://cn.vuejs.org/v2/guide/migration.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7￼ 13 vue.config.debug取消不再需要，因为警告信息将默认在堆栈信息里输出14 router.go =&gt; router.push15 v-link指令更新为router-link标签","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"部署警告A Parser-blocking...","slug":"部署警告A Parser-blocking","date":"2018-05-18T15:29:18.000Z","updated":"2018-05-18T16:44:52.000Z","comments":true,"path":"2018/05/18/部署警告A Parser-blocking/","link":"","permalink":"https://qiaoding18.github.io/2018/05/18/部署警告A Parser-blocking/","excerpt":"","text":"问题情况在本地部署公司项目的时候，devserver渲染不出来。排错，非node版本问题（nvm切换node版本部署），非本地环境问题（可成功部署其他项目）发现在非Chrome浏览器都可渲染，在Chrome中会有报错。发现使用了Chrome屏蔽广告插件，在使用第三方地图时候有警告： parser-blocking, cross site (i.e. different eTLD+1) script… 分析扩展抓包分析发现在请求第三方地图时会有两次请求转发，Chrome广告拦截器会将请求拦截，导致在渲染时，由于拿不到响应数据，造成不能渲染的情况 对于正常情况下的警告，查找相似错误原因有使用document.write渲染。分析原因是第三方地图的原因。 也了解了一些其他问题。比如在一些第三方代码中加入了广告代码例子上例中的脚本被注入了代码，使用了相关加密操作，关键点在于执行弹窗内容有一个iframe包裹的另外一个请求。猜想在项目中遇到的情况也是类似。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"vue的nextTick机制","slug":"Vue的nextTick","date":"2018-05-02T07:32:00.000Z","updated":"2018-05-08T12:54:24.000Z","comments":true,"path":"2018/05/02/Vue的nextTick/","link":"","permalink":"https://qiaoding18.github.io/2018/05/02/Vue的nextTick/","excerpt":"","text":"nextTick用法在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获得更新后的DOM 原理1、JavaScript是单线程，时间点上只能做一个事情2、任务分同步异步3、异步任务大致分为：宏任务、微任务4、所有同步任务都在主线程上执行，形成一个执行栈5、主线程之外，有个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件6、一旦执行栈中的所有同步任务执行完毕，轮询机制就会读取任务队列中的微任务，其次是宏任务，看看里面有哪些事件。对应哪些异步任务，于是不再等待，进入执行栈执行7、事件轮询不断执行，看任务队列有没等着的 vue实现vue大多数情况下优先使用微任务，很少的地方使用宏任务 vue对于nextTick的宏任务实现优先检测setImmediate，然后是MessageChannel支持情况123456789101112131415161718if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125;else if (typeof MessageChannel !== 'undefined' &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]')) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; 如果都不支持，会用setTimeout123456else &#123; /* istanbul ignore next */ macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; vue对于nextTick的微任务实现优先检测Promise123456789101112if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() microTimerFunc = () =&gt; &#123; p.then(flushCallbacks) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125;&#125; 如果不支持Promise，还是用宏任务1234else &#123; // fallback to macro microTimerFunc = macroTimerFunc&#125; vue什么地方宏任务or微任务DOM事件中用Vue.nextTick默认使用宏任务，其他地方使用Vue.nextTick默认是微任务 其实从源码中注释中可以看出Vue最开始都是使用微任务方式，后面出现了bug，才引入了宏任务方式 举个例子1234567891011121314151617export default &#123; data () &#123; return &#123; msg: 0 &#125; &#125;, mounted () &#123; this.msg = 1 this.msg = 2 this.msg = 3 &#125;, watch: &#123; msg () &#123; console.log(this.msg) &#125; &#125;&#125; watch：对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。在实例化时为每个键调用 $watch() 这段打印的是只输出一个3 关于setImmediate、MessageChannel VS setTimeout为什么要优先创建macroTask而不是setTimeout？h5中规定setTimeout的最小时间时延是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而MessageChannel和setImmediate的延迟明显是小于setTimeout的 因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先回去等待所有的进程执行完成之后再去一次更新。这样的性能优势很明显，比如：在mounted的时候变量值被循环加加1000次。每次加加时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run如果每次++都会直接操作DOM更新视图，会非常消耗性能。所以Vue实现了一个queue队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中的Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中Watcher的run。所以不会执行1000次Watcher的run。最终更新视图只会将test对应的DOM的0变成1000.保证更新视图操作DOM的动作是在当前执行栈完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"某讯的硬件加速","slug":"硬件加速","date":"2018-05-01T07:32:00.000Z","updated":"2018-05-02T14:40:22.000Z","comments":true,"path":"2018/05/01/硬件加速/","link":"","permalink":"https://qiaoding18.github.io/2018/05/01/硬件加速/","excerpt":"","text":"劳动节假期宣告了春招的结束（对我来说）投简历时候看到了这个 http://join.qq.com打开这个网页，大概也就是几秒功夫，我的小办公本的风扇就开始叫唤了 对比一下打开前后的区别之前：之后： emmmm 流弊 控制台点开，点了下这个然后 嗯，硬件加速的锅了 css3动画中大量运用了translate3d，用chrome提供的查看复合图层的这个功能可以看到有很多层 每个图层GPU单独绘制，过多会导致资源消耗过多，就会很卡了这里总结一下这方面的知识 普通图层和复合图层可以这样理解，浏览器渲染的图层一般包含两大类：普通图层、复合图层首先，普通文档流可以理解为一个复合图层，在文档流中不管添加多少元素，其实都是在同一个复合图层中其次，absolute、fix布局，虽然可以脱离普通文档流，但还是属于默认复合层 通过硬件加速的方式，会声明一个新的复合图层，它会单独分配资源它也是肯定脱离普通文档流的，这样不管复合图层中怎么变化，也不会影响默认复合层里的回流重绘可以这样理解，GPU中各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 如何变成复合图层将该元素变成一个复合图层，就是传说中的硬件加速技术1、最常用的方法：translate3d、translateZ2、opacity属性\\过度动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）3、will-change属性，一般配合opacity与translate使用，作用是提前告诉浏览器要变化，这样浏览器会开始做一下优化工作4、video、iframe、canvas、webgl、svg5、其它，譬如以前的flash插件6、元素有一个包含复合层的后代节点（换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里）7、元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 如果有一个元素，他的兄弟元素在复合层中渲染，而这个兄弟元素的z-index比较小，那么这个元素（不管有没有用到硬件加速样式）都会被放到复合层中 问题在webkit css3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素后面其他元素（层级比这个元素高的，或者相同的，并且relative或absolute属性相同的），会默认变为复合层渲染用z-index让它高一点就解决了 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"聊聊Dreamweaver","slug":"聊聊Dreamweaver","date":"2018-04-28T14:34:00.000Z","updated":"2018-04-28T16:42:46.000Z","comments":true,"path":"2018/04/28/聊聊Dreamweaver/","link":"","permalink":"https://qiaoding18.github.io/2018/04/28/聊聊Dreamweaver/","excerpt":"","text":"当你看到这张图时会想起这款Adobe家族中最绿的那个Dreamweaver老弟吗 如今的Web开发者可能对于DW的印象只是一个陈旧的老古董软件，与如今日新月异的Web发展完全跟不上。 在十年之前，你不认识我我不认识你的时候DW有一个美妙的中文名称：“梦想编织者” Adobe Dreamweaver，简称“DW”，是美国MACROMEDIA公司开发的集网页制作和管理网站于一身的所见即所得网页编辑器，DW是第一套针对专业网页设计师特别发展的视觉化网页开发工具，利用它可以轻而易举地制作出跨越平台限制和跨越浏览器限制的充满动感的网页。 DW在诞生之初作为一款所见即所得的编辑器，或者说是制作器，带给了最初的Web开发者难以置信的制作效率。 Dreamweaver可以用最快速的方式将Fireworks，FreeHand，或Photoshop等档案移至网页上。使用检色吸管工具选择荧幕上的颜色可设定最接近的网页安全色。对于选单，快捷键与格式控制，都只要一个简单步骤便可完成。 在Adobe家族强势配合下，DW的存在为多少Web开发者编织出了他们的梦想。再配上可视化的编辑能力，分分钟画出一屏幕的表格等等强势的功能给当时的Web开发带来了新纪元。 DW当初强势的表现很难让人们想象到短短的十年内会有如此的大落，而与之相比Adobe家族的其他产品几乎都还强势的活跃在软件市场上。到底是什么原因导致DW到了如此的地步，是人性的扭曲还是道德的沦丧…… 1、Web的快速发展导致了DW的落伍。正因为DW的出现加速了Web的发展，而最值得DW骄傲的所见即所得能力却成为了它最致命的弱点。千篇一律的表格与个性化网页格格不入、自动生成的代码拉低了巨型工程的效率、黑箱式的操作给后期维护提升了成本…… 2、国内的Web发展晚于国外，且国内工厂式的学习班把DW变成为了烂大街的软件。再加上Web开发上手容易，而极为人性化的DW让开办补习班的人轻松得到了收益，但这让DW在国内一再贬值。最终，使用DW已不算什么本事。 一代代的Web开发者都在改进书写代码环境上的努力，而越是受到历史包袱拖累的产品，越难有革命性的创新，windows就是很好的证明，向后兼容严重影响了安装文件的大小和对系统资源的需求。我们盖房子，都要重打地基，罕有在旧地基之上盖新房的，也是因为，旧的地基限制了上层建筑的格局 在开源大潮滚滚袭来的今天，Web开发者们都在讨论着Sublime、Webstorm、Atom等等的IDE，这时的DW就像是穿着重铁甲拿着尚方宝剑与那些精干的陆战队员比拼一样，宝剑依然锋利，铁甲依然坚固，只是在思维上已经落后了许多。 红尘滚滚，后浪推前。 DW的没落给如今作为最新潮的Web开发者们以警示：要紧跟技术的发展，要紧跟时代的发展。 但也不应该忘记前一辈的努力才有了如今Web的火热。 最后，Coder你今天开源了吗 微信：西邮3G实验室微博：西邮移动应用开发实验室网址：www.xiyoumobile.com地址：西邮东区逸夫楼FZ155","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"Token","slug":"Token","date":"2018-04-27T14:18:00.000Z","updated":"2018-04-29T14:41:26.000Z","comments":true,"path":"2018/04/27/Token/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Token/","excerpt":"","text":"简介token意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 用户第一次登录，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码 toke组成： uid（用户唯一的身份标识） time（当前时间的时间戳） sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露） token在服务端不需要存储用户的登录记录，流程：1、客户端使用用户名和密码请求登录2、服务端收到请求，验证用户名和密码3、验证成功后，服务端会生成一个token，然后把这个token发送给客户端4、客户端收到token后把他存储起来，可以放在cookie或者LocalStroage里5、客户端每次向服务器请求时都需要带上服务器发给的token6、服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据 token机制认证登录方式：1、用Mac地址作为token客户端：客户端在登录时获取设备的Mac地址，将其作为参数传递到服务端服务端：服务端接收到该参数后，便用一个变量来接收，同时将其作为token保存在数据库 2、用sessionId作为token客户端：客户端携带用户名和密码登录服务端：接收到用户名和密码后进行校验，正确就将本地获取的sessionId作为token返回给客户端，客户端以后只需带上请求的数据即可。这样不用存储数据，但是session过期客户端必须重新登录 保密性高的话，两个都用上。将设备的Mac地址与用户名密码同时作为token进行认证 把token用在https Token的优点token相对于cookie机制的好处1、支持跨域访问：cookie不允许跨域访问的，这一点对token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输2、无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息3、更适用CDN：可以通过内容分发网络请求你服务端的所有资料，而你的服务端只要提供API即可 token过程第三方认证登录过程：1、用户选择使用第三方认证登录2、我的服务器给客户端返回第三方的连接，在连接中带上认证的id3、客户端请求第三方链接4、第三方链接返回登录和授权5、客户端登录第三方6、第三方携带一个授权码，并返回我的服务器链接7、客户端携带授权码请求我的服务器8、我的服务器得到授权码9、我的服务器拿着授权码去请求第三方的token10、第三方拿到授权码并验证，验证后创建token11、第三方把token再返回给我的服务器12、得到token用于之后的验证 授权码的安全：1、和我的服务器申请的appid、appsecret相关，第三方只认申请过的，才给token2、让授权码有时间限制3、授权码只能换一次token","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"随想","slug":"随想","date":"2018-04-27T11:37:00.000Z","updated":"2018-04-28T16:49:58.000Z","comments":true,"path":"2018/04/27/随想/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/随想/","excerpt":"","text":"写bug，解决bug，看别人bug，讲明白bug","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"怎么防止被运营商劫持","slug":"怎么防止被运营商劫持","date":"2018-04-27T11:32:00.000Z","updated":"2018-05-02T14:41:02.000Z","comments":true,"path":"2018/04/27/怎么防止被运营商劫持/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/怎么防止被运营商劫持/","excerpt":"","text":"运营商通过HTTP劫持进行插入广告，下载软件等 运营商劫持原理1、在用户的浏览器连上被访问的网站服务器，发送了HTTP请求后，运营商的路由器会首先收到此次http请求2、之后运营商路由器的旁路设备标记此TCP连接为http协议3、之后可以抢在网站服务器返回数据之前发送http协议的302状态码（临时性重定向，让用户访问新的URI）进行劫持，或者直接返回修改后的html代码4、浏览器收到302代码后就会跳转到错误的地址，或者修改了html有广告5、随后返回的真正数据到达后反而会被丢弃 关键点：需要http劫持，首先需要进行标记：如果是http协议，那么进行劫持，否则不进行劫持 如何避免旁路设备中检测http协议的模块比较简单一般只会检测TCP连接建立后的第一个数据包，如果其是一个完整的http协议才会被标记如果并非是一个完整的http协议，由于无法得到足够多的劫持信息，所以并不会被标记为http协议 所以，防止劫持的方法是：将http请求分拆到多个数据包内，进而骗过运行商，防止了http劫持。而目标网站的操作系统的TCP/IP协议栈比较完善，收到的仍旧是完整的http请求，所以也不会影响网页浏览 如何实现可以在本地架设一个代理服务器，在代理服务器将浏览器的http请求进行拆包，浏览器设置本地的代理服务器即可。而且https也不会劫持","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"异步操作和async函数","slug":"异步操作和async函数","date":"2018-04-27T11:31:00.000Z","updated":"2018-05-02T14:41:48.000Z","comments":true,"path":"2018/04/27/异步操作和async函数/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/异步操作和async函数/","excerpt":"","text":"关于异步ES6诞生前，异步编程的方法大概有下面4面 回调函数 事件监听 发布\\订阅 Promise对象 ES7中的async函数更是给出了异步编程的终极解决办法。 基本概念异步所谓“异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好准备再回头执行第二段。比如，有一个任务是读取文件进行操作，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。相应地，连续的执行就叫作同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能等待。 回调函数JS对异步的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数中，等到重新执行该任务时直接调用这个函数。callback直译过来就是“重新调用” 读取文件例子：123456fs.readFile('xxoo', function(err, data)&#123; if(err)&#123; throw err; &#125; console.log(data);&#125;) 上面代码中。readFile函数的第二个参数就是回调函数，也就是任务的第二段。等到操作系统返回了xxoo这个文件以后，回调函数才会执行。 一个有趣的问题，为什么Node.js约定回调函数的第一个参数必须是错误对象err（如果没有错误，该参数就是null），原因就是执行分成两段，在这两段之间抛出的错误程序无法捕获，只能当作参数传入第二段。 Promise回调函数本身并没有问题，问题出在多重嵌套，会出现回调函数地狱Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一个新的写法，允许将回调函数的横向加载改成纵向加载。采用Promise，连续读取多个文件的写法如下：1234567891011121314var readFile = require('fs-readFile-promise');readFile(fileA).then(function(data)&#123; console.log(data.toString);&#125;).then(function()&#123; return readFile(fileB);&#125;).then(function(data)&#123; console.log(data.toString());&#125;).then(function(err)&#123; console.log(err);&#125;); 上面的代码中使用了fs-readfile-promise模块，其作用是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 Promise的最大问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆then，原来语义变得不是很清楚有木有更嗨的写法呢？ Generator函数协程传统的编程语言早已有异步编程的解决方案（尤其是多任务的解决方案）。其中有一种叫做“协程”，意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。其运行流程大致如下。 1、协程A开始执行 2、协程A执行到一半，暂停，执行权转移到协程B 3、（一段时间后）协程B交还执行权 4、协程A恢复执行上面的协程A就是异步任务，因为它分成两段执行。举例来说，读取文件的协程写法如下。12345fucntion asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面的函数asyncJob是一个协程，他的奥妙在于其中的yield。他表示执行到此处执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。他的最大优点就是代码的写法非常像同步操作，如果去除yield命令，则完全一样。 Generator函数的概念Generator函数是协程在ES6中的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。1234567function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next()// &#123;value: 3, done: false&#125;g.next()// &#123;value: undefined, done: true&#125; 上面的代码中，调用Generator函数会返回一个内部指针（及遍历器）g。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例中是到 x + 2为止。换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。 Generator函数的数据交换和错误处理Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外它还有两个特性使它可作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。1234567function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; 第二个next参数2，这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果被函数体内的变量y接收。因此，这一步的value属性返回的就是2（变量y的值）。Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。123456789101112function* gen(x)&#123; try&#123; var y = yield x + 2; &#125;catch(e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 上面的最后一行，Generator函数体外使用指针对象的throw方法抛出的错误，可以被函数体内的try…catch代码块捕获。这意味着，出错的代码与处理错误的代码实现了时间和空间上的分离，这对于异步编程来说无疑是很重要的。 异步任务的封装如何使用Generator函数执行一个真实的异步任务123456var fetch = require('node-fetch');function* gen()&#123; var url = \"https://xxoo\"; var result = yield fetch(url); console.log(result.xxoo);&#125; Generator函数封装了一个异步操作，先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说的，这段代码非常像同步操作，只是加上了yield命令。 执行方法如下12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;) 首先执行Generator函数获取遍历器对象，然后使用next方法（第二行）执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next方法。可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理（即何时执行第一阶段，何时执行第二阶段）却不方便。 Thunk函数参数的求值策略12345var x = 1;function f(m)&#123; return m * 2;&#125;f(x + 5) // 12 1、先定义函数f2、然后向他传入表达式x+5f(x + 5)传值调用时等同于f(6) “传值调用”进入函数体前就计算x+5的值，再将这个值传入函数f。 “传名调用”直接将表达式x+5传入函数体，只在用到它时求值。 Thunk函数的含义编译器的“传名调用”实现往往是先将参数放到一个临时函数中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。1234567891011function f(m)&#123; return m * 2;&#125;f(x + 5);//等同于var thunk = function()&#123; return x + 5;&#125;;function f(thunk)&#123; return thunk() * 2;&#125; 代码中，函数f的参数x+5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。这就是Thunk函数的定义，他是“传名调用”的一种实现策略，用来替换某个表达式。 JS语言的Thunk函数JS是传值调用，他的Thunk函数含义有所不同。在JS语言中，Thunk函数替换的不是表达式，而是多参数函数，它将其替换成单参数的版本，且只接受回调函数作为函数。1234567891011// 正常的readFile 多参数fs.readFile(fileName, callback);// Thunk版本的readFile 单参数var readFileThunk = Thunk(fileName);readFileThunk(callback);var Thunk = function(fileName)&#123; return function(callback)&#123; return fs.readFile(fileName, callback); &#125;;&#125;; 代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。123456789var Thunk = function(fn)&#123; return function()&#123; var args = Array.prototype.slice.call(arguments); return function(callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;; 使用上面转换器生成fs.readFile的Thunk函数如下12var readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback); Thunkify模块用于生产环节的转换器，建议使用Thunkify模块用法：123456var thunkify = require('thunkify');var fs = require('fs');var read = thunkify(fs.readFile);read('package.json')(function(err, str)&#123; // .....&#125;); Generator函数的流程管理Thunk函数可以用于Generator函数的自动流程管理。读取文件为例，下面的Generator函数封装了两个异步操作。123456789var fs = require('fs');var thunkify = require('thunkify');var readFile = thunkify(fs.readFile);var gen = function* ()&#123; var r1 = yield readFile('xx'); console.log(r1.toString()); var r2 = yield readFile('oo'); console.log(r2.toString());&#125;; 代码中，yield命令用于将程序的执行权移出Generator函数。就需要一种方法，将执行权再交还给Generator函数。 Thunk函数的自动流程管理Thunk函数真正的威力在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器123456789101112function run(fn)&#123; var gen = fn(); function next(err, data)&#123; var result = gen.next(data); // 先next if(result.done)&#123; // 判断结束 return; &#125; result.value(next); // 没结束 next函数传入Thunk函数 &#125; next(); // 递归执行&#125;run(gen); 上面的run函数就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没有结束，就将next函数再传入Thunk函数（result.value属性），否则直接退出。 有了这个执行器，执行Generator函数就方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作都要是Thunk函数。也就是说，跟yield命令后面的必须是Thunk函数。1234567var gen = function* ()&#123; var f1 = yield readFile('fileA'); var f2 = yield readFile('fileB'); // ... var fn = yield readFile('fileN');&#125;;run(gen); 上面的代码中，函数gen封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写的像同步操作，而且一行代码就可以执行。Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制自动控制Generator函数的流程，接收和交换程序的执行权。回调函数可以做到这一点，Promise对象也可以做到这一点。 co模块co模块用于Generator函数的自动执行。123456var gen = function* ()&#123; var f1 = yield readFile('xx'); var f2 = yield readFile('oo'); console.log(f1.toString()); console.log(f2.toString());&#125;; co模块可以让你不用编写Generator函数的执行权12var co = require('co');co(gen); 上面的代码中，Generator函数只要传入co函数就会自动执行。co函数返回一个Promise对象，因此可以用then方法添加回调函数。123co(gen).then(function()&#123; console.log('Generator函数执行完成');&#125;) 上面的代码中，等到Generator函数执行结束，就会输出一行提示。 async函数含义ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。Generator函数，依次读两个文件12345678910111213141516171819202122232425var fs = require('fs')var readFile = function(fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if(error)&#123; reject(error); &#125; resolve(data) &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('xx'); var f2 = yield readFile('oo'); console.log(f1.toSrting()); console.log(f2.toSrting());&#125;// 写成async函数如下var asyncReadFile = async function()&#123; var f1 = await readFile('xx'); var f2 = await readFile('oo'); console.log(f1.toString()); console.log(f2.toString());&#125; 比较会发现，async函数就是将Generator函数的星号替换成async，将yield替换成await，仅此而已。async函数对Generator函数的改进体现在以下4点。1、内置执行器。Generator函数的执行必须靠执行器，所以才有co模块，而async函数自带执行器。也就是说，async函数的执行与普通函数一模一样，只要一行var result = asyncReadFile();2、上面代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。完全不像Generator函数，需要调用next函数的执行与普通函数一模一样，只要一行3、更好的语义。async和await比起星号和yield，语义更清楚。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。4、更广的适用性。co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这是等同于同步操作）5、返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。可以用then方法指定下一步的操作。 进一步，async函数完全可以看作由多个异步操作包装成的一个Promise对象，而await命令就是内部then命令的语法糖。 async函数的实现async函数的实现就是将Generator函数和自动执行器包装在一个函数中。123456789async function()&#123; // ...&#125;// 等同于function fn(args)&#123; return spawn(fucntion* ()&#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中spawn函数就是自动执行器 async函数的用法同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行时，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。12345678async function getStockPriceByName(name)&#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function(result)&#123; console.log(result);&#125;); 代码是一个获取股票报价的函数，函数前的async关键字表明该函数内部有异步操作。调用时，会立即返回一个Promise对象。 下例指定了多少秒后返回一个值：12345678910function timeout(ms)&#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms)&#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 注意点await命令后面的Promise对象，运行结果可能是Rejected，所以最好把await命令放在try…catch代码块中123456789101112131415async function myFunction()&#123; try&#123; await somethingThatReturnsAPromise(); &#125;catch(err)&#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction()&#123; await somethingThatReturnsAPromise().catch(function(err)&#123; console.log(err); &#125;);&#125; await命令只能用在async函数中，在普通函数中会报错 与Promise、Generator的比较一个DOM操作的动画效果，前一个开始后一个结束。Promise的写法12345678910111213141516171819function animate(elem, animations)&#123; // 变量ret用来保存上一个动画的返回值 var ret = null; // 新建一个空的返回值 var p = Promise.resolve(); // 使用then方法添加所有动画 for(var anim in animations)&#123; p = p.then(function(val)&#123; ret = val; return anim(elem); &#125;) &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e)&#123; // 忽略错误，继续执行 &#125;).then(function()&#123; return ret; &#125;);&#125; 比回调有很大改进，但是都是Promise的API，操作本身的语义不容易看出来接着是Generator函数的写法：12345678910111213function animate(elem, animations)&#123; return spawn(function* ()&#123; var ret = null; try&#123; for(var anim of animations)&#123; ret = yield anim(elem); &#125; &#125;catch(e)&#123; // 忽略错误继续执行 &#125; return ret; &#125;);&#125; 代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部出现在spawn函数的内部。问题在于必须有一个任务运行自动执行Generator函数，上面的spawn函数就是自动执行器，它返回一个Promise对象，而且保证yield语句后面的表达式必须返回一个Promise。async函数的写法1234567891011async function animate(ele, animations)&#123; var ret = null; try&#123; for(var anim of animations)&#123; ret = await anim(elem); &#125; &#125;catch(e)&#123; // 忽略错误 继续执行 &#125; return ret;&#125; 这个太好了","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"原型链","slug":"原型链","date":"2018-04-27T11:31:00.000Z","updated":"2018-05-02T14:44:46.000Z","comments":true,"path":"2018/04/27/原型链/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/原型链/","excerpt":"","text":"普通对象与函数对象JS对象对象分为普通对象和函数对象，Object、Function是JS自带的函数对象12345678910var o1 = &#123;&#125;;var o2 = new Object();var o3 = new f1();// 都是objectfunction f1()&#123;&#125;;var f2 = function()&#123;&#125;;var f3 = new Function('str', 'console.log(str)')// 都是functionconsole.log(typeof Object); //function console.log(typeof Function); //function 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 构造函数12345678function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name) &#125; &#125;var person1 = new Person('qd', 21, 'Software Engineer');var person2 = new Person('wyj', 21, 'Doctor'); 上面例子中person1和person2都是Person的实例。这两个实例都有一个constructor（构造函数）属性，该属性（是一个指针）指向Person。即：12console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //true person1和person2都是构造函数Person的实例实例的constructor属性指向了实例的构造函数 原型对象定义函数对象时都有一个prototype属性，这个属性指向函数的原型对象。12345678function Person()&#123; &#125;;Person.prototype.name = \"xx\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;var person1 = new Person();person1.sayName(); // xx 每个对象都有prototype属性，但是只有函数对象才有prototype属性关于原型对象，把上例改成123456Person.prototype = &#123; name: 'xx', sayName: function()&#123; alert(this.name); &#125;&#125; 原型对象，顾名思义，它就是一个普通对象。就是Person.prototypePerson.Prototype有默认属性constructor，默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性（是一个指针）指向prototype属性所在的函数1Person.prototype.constructor == Person 且Person的实例也具有constructor属性，说明Person.prototype也是Person的实例原型对象就是普通对象，但是Function.prototype除外，它是函数对象，但他很特殊，没有prototype属性123function Person()&#123; &#125;;console.log(typeof Person.prototype); //Objectconsole.log(typeof Function.prototype); //Function 凡是通过new Function()产生的对象都是函数对象。原型对象的用处，主要用于继承12345678var Person = function(name)&#123; this.name = name;&#125;;Person.prototype.getName = function()&#123; return this.name;&#125;var person1 = new person('xx');person1.getName(); // xx 通过给Person.prototype设置了一个函数对象的属性，那由Person的实例(person1)出来的普通对象就继承了这个属性。 protojs在创建对象的时候，都有一个叫做proto的内置属性，用于指向创建它的构造函数的原型对象。对象person1有一个proto属性，创建它的构造函数是Person，构造函数的原型对象是Person.prototype所以 person1.proto == Person.prototype123Person.prototype.constructor == Person;person1.__proto__ == Person.prototype;person1.constructor == Person; 构造器创建对象是 var obj = new Object();obj是构造函数(Object)的一个实例。所以：obj.constructor = Objectobj.proto === Object.prototype比较特殊的有：Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。Object.prototype.proto === null","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"移动端touch和click","slug":"移动端touch和click","date":"2018-04-27T11:30:00.000Z","updated":"2018-04-27T14:31:52.000Z","comments":true,"path":"2018/04/27/移动端touch和click/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/移动端touch和click/","excerpt":"","text":"touch1、touch事件在某些场景下存在点击穿透的问题2、touchstart事件是触摸屏幕就会触发，touchend事件是手指离开屏幕就会触发，而有时候我们仅仅只是想滑动屏幕，但却会触发这两个事件。 移动端事件触发的事件顺序为 touchstart -&gt; touchout -&gt; click clickclick会有300ms的延迟，是因为苹果Safari中最早为了确定用户是双击还是单机而将ckick事件加了300ms的延迟，来等待用户的二次点击，但之后发展中300ms就显得卡顿。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 解决300ms的方法1、在html文档中添加meta标签12&lt;meta name=\"viewport\" content=\"user-scalable=no\"/&gt;&lt;meta name=\"viewport\" content=\"init-scale=1.0,maximum-scale=1.0\" /&gt; 表明这个页面是可放缩的，那么双击放缩的功能就没有意义了，此时浏览器可以禁用默认的双击放缩行为并且去掉300ms的点击延迟。 2、改变默认的视口宽度1&lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; 我们通过上述标签设置移动浏览器的宽度等于设备的视窗宽度。随着响应式的普及，很多站点都已经对移动端做过适配了，这时候就不需要双击缩放了。如果能识别出一个网站是响应式网站，那么浏览器就可以认为已经对移动端做了优化和适配，那么久无需双击操作了。如果页面比较简单，可以用touch事件，如果页面比较复杂，直接用click事件，同意用click的事件的好处是不应担心页面点击穿透的问题。 点击穿透：使用touchstart去代替click事件有两个不好的地方。第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。 这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。 解决办法1、只用touch 把页面的所有click全部换成touch事件。a标签的href也是click，需要去掉换成js控制的跳转，或者不用a标签 2、只用click 会带来300ms延迟 3、使用fastclick 用这个取消300ms延迟，随后只用click 4、遮挡 给上层的消失做一个fade效果，并设置动画大于300ms，这样当延迟的click触发时，就不会穿透到下方元素了 5、禁掉放缩/更改默认视口宽度 不能放缩就不用等待300ms","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"移动端适配（像素）","slug":"移动端适配（像素）","date":"2018-04-27T11:30:00.000Z","updated":"2018-04-27T14:31:46.000Z","comments":true,"path":"2018/04/27/移动端适配（像素）/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/移动端适配（像素）/","excerpt":"","text":"像素和DPR像素像素分为两种：1、设备像素：设备屏幕的物理像素，任何设备的物理像素的数量都是固定的。2、css像素：又称为逻辑像素，是为web开发者创造的，在css和JavaScript中使用的一个抽象层。 每一个css声明和几乎所有的JavaScript属性都使用css像素，因此实际上从来用不上设备像素，唯一例外的是screen.width/height123// css设置的是逻辑像素width: 300px;font-size: 16px; 放缩 PC端，css一个像素对应电脑屏幕的一个物理像素，有特殊情况比如电脑放缩，浏览器放缩 PE端，由于屏幕尺寸的限制，放缩是经常性的操作 设备像素是深蓝色，css像素是半透明左图，缩小时，一个设备像素覆盖了多个css像素右图，放大时，一个css像素覆盖了多个设备像素 无论我们进行缩小还是放大操作，元素设置的css像素是始终不变的，而一个css像素对应多少个设备像素是根据当前的缩放比例来决定的。 设备像素比DPRDPR设备像素比 = 设备像素 / css像素（某一方向上）如今设备的PPI（像素密度很高）屏幕分辨率提高了，屏幕尺寸没有变换，会导致在同样大小的屏幕中，像素更多，导致DPR增加。普通屏幕下的图片在这种高分屏中会导致图片模糊。 实际上，此时的CSS像素对应着以后要提到的理想视口，其对应的javascript属性是screen.width/screen.height 而对于设备像素比DPR也有对应的javascript属性window.devicePixelRatio 以iphone5为例，iphone5的CSS像素为320px*568px，DPR是2，所以其设备像素为640px*1136px 般都不会用到处理css border-width:0.5px;的问题，所以为认为目前dpr需要处理的问题是retina屏幕下高清图片的显示问题，一般设置即可：1&lt;meta name=\"viewport\" content=\"width=devide-width,initial-scale=1,maximum-scale=1, minimum-scale=1,user-scalable=no\"&gt; viewport由来由于手机屏幕相对桌面显示器要小很多，传统网页上的设计在手机上的体验会很糟糕，阅读性非常差。为了让手机也能获得良好的网页浏览体验，Apple 在移动版 Safari 中定义了 viewport meta 标签(如果没记错最早提出的话)，用于创建一个虚拟窗口（layout viewport），这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定义为980px。然后将虚拟窗口映射到移动设备的屏幕上，按比例缩放并重新渲染网页。 关于viewport的功能是用来约束你网站中最顶级包含块元素（containing block）\\的。实际上等于浏览器窗口 划分虚拟窗口（layout viewport）移动浏览器默认情况下把viewport设置为一个比较宽的值（防止太窄而在可视区域中显示错乱），该默认的 viewport 称为 layout viewport宽度可通过 JS 获取(基本所有设备都支持)document.documentElement.clientWidthdocument.documentElement.clientHeight 视觉窗口（visual viewport）浏览器可视区域大小。可理解为手机物理屏幕。宽度可通过 JS 获取(不支持Android2, Opera Mini, UC8)window.innerWidthwindow.innerHeight ideal viewport这个viewport能将设备上的页面设置能最理想的尺寸。因此，每种设备的ideal viewport的尺寸是不一样的。一个完美适配移动设备的 viewport。理想状态是不需要用户缩放和横向滚动条就能正常查看，显示的文字大小合适，不区分分辨率，屏幕密度等。 UI的设计稿就应该按照css像素（如ipohone6应该给375px的设计稿）给，这样我们我们量出来直接写不就刚好。但是！！！我们忽略了一个问题！那就是，我们在移动端中会使用rem方案，来做不同设备间的适配，可以实现同一份代码在不同的设备上展示的效果都是合适的。而rem实际上就是做了物理像素和css像素之间的转换。我们先来po一下代码：12345678910(function () &#123; function changeRootFont() &#123; var designWidth = 750, rem2px = 100; document.documentElement.style.fontsize = ((window.innerWidth / designWidth) * rem2px) + 'px'; //iphone6: (375 / 750) * 100 + 'px'; &#125; changeRootFont(); window.addEventListener('resize', changeRootFont,false);&#125;)(); 可以看到，我们通过动态的获取设备独立像素，然后除以设计稿的宽度，然后赋给根字体的fontsize，以致来动态改变跟字体大小，做到自适应。但至于为什么要乘100，首先375 / 750是0.5，浏览器默认最小字体为12px，所以我们需要放大一些，而100又很好算，我们只需要将设计稿量出来的长度（px），小数点向左移2位，单位变成rem就好了。 rem相当于为我们做了物理像素与css像素之间的转换。所以设计稿直接给物理像素的就好了。当然，直接给css像素的，我们也可以直接量多少写多少，也能完美适配，但是！这个完美适配只对于一个设备！或者是一类，一类css像素就是375px的设备，显然，这不合适。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"页面优化方案 （重排重绘）","slug":"页面优化方案-（重排重绘）","date":"2018-04-27T11:29:00.000Z","updated":"2018-04-29T14:30:00.000Z","comments":true,"path":"2018/04/27/页面优化方案-（重排重绘）/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/页面优化方案-（重排重绘）/","excerpt":"","text":"重排重绘浏览器下载完页面中的所有组件——HTML标记、JavaScript、CSS、图片之后会解析生成两个内部数据结构——DOM树和渲染树 DOM树 表示 页面结构渲染树 表示 DOM节点如何显示 DOM树中的每一个需要显示的节点在渲染树种至少存在一个对应的节点，隐藏的DOM元素disply值为none 在渲染树中没有对应的节点。 重排：当DOM的几何属性（宽高）改变，切其他元素的几何属性和位置也因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。重绘：完成重排后，浏览器会重新绘制受影响的部分到屏幕。 对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，他可能需要多次计算才能确定好其在渲染树中结点的属性，要花费更多时间。注：改变元素的背景色并不影响元素的宽和高，只发生重绘 重排发生条件重排比导致重绘1、添加或者删除可见的DOM元素2、元素位置改变3、元素尺寸改变4、元素内容改变5、页面渲染初始化6、浏览器窗口尺寸改变 优化方案一、内容层面 1、DNS解析优化 2、避免重定向 二、网络传输阶段 1、减少传输时候的内容 （1）缓存 （2）cookie优化 （3）文件压缩 2、减少请求的次数 （1）文件适当的合并 （2）雪碧图 3、异步加载 4、懒加载三、渲染阶段 1、js放在底部、css放顶部 2、减少重排重绘 3、减少DOM结点四、脚本执行阶段 1、尽量减少结点查找 2、事件委托 细节1、缓存 （1）浏览器第一次访问某一文件，这时候没有被缓存，直接从服务端获取文件，并且存入浏览器缓存。并且服务端设置响应头：Expires、Cache-Control，Last-Modified、ETage。 （2）如果设置了Expires或者Cache-Control，，如果指定时间内在请求文件时，只要不强制刷新缓存，浏览器会直接读取缓存而不再请求服务器 （3）如果没有设置Expires或者Cache-Control或者过期了，就需要再次请求服务器，发起请求时在请求头加上If-Modified-Sinse或者If-None-Match，服务器端判断最新的文件是否发生了更新，如果没有，总则返回响应状态码304，不带任何响应体 2、按回车、浏览器刷新按钮、F5、Ctr+F5的区别 （1）回车，浏览器会判断是否有缓存，并且根据Expires或者Cache-Control判断缓存是否过期，如果没有，就不会发起请求，直接使用缓存。否则就需要像服务器发起请求再验证。 （2）浏览器刷新按钮和F5效果相同，不管是否有Expires或者Cache-Control，都会强制去请求服务器，进行再验证，根据If-Modified-Sinse或者If-None-Match判断是否要返回304，如果是，浏览器就会继续使用缓存。 （3）按Ctr+F5时，也是不管是否有Expires或者Cache-Control，都会强制去请求服务器，但是并不会进行再验证，服务器会直接把最新的内容返回给浏览器，压根就不考虑缓存的存在或者是否过期。 3、为什么用Last-Modified还不够，要用ETag实体标签验证 （1）有些文档会被周期性的重写，但实际包含的数据是一样的，ETag是版本，就不会更新 （2）有些文档可能被修改了，但是修改并不重要，没必要更新缓存 （3）有些服务器无法准确判定页面的最后修改日期 （4）文档在毫秒级间隙发生变化（如实时监控），以秒为颗粒度的Last-Modified就不够用了 图片优化1、base64（小图片）2、cdn3、懒加载4、雪碧图 函数节流某些代码不可以在没有时间简短的情况连续重复执行 设置timeid，给要执行的函数外套上setTimeout。每次要执行就清除一次timeid，来阻止之前的调用被执行。然后，创建一个新的定时器调用要执行的函数 函数防抖如果一直触发一个事件，函数节流的方法定义的方法永远不会执行，就像一个水龙头，如果关闭了，永远不会出水；函数防抖的方法像一个关闭水龙头不好用，当关闭水龙头隔一段时间会有滴水一样。就是一个事件如果频繁触发，会隔一段时间执行一次。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"协商缓存","slug":"协商缓存","date":"2018-04-27T11:29:00.000Z","updated":"2018-04-27T14:32:04.000Z","comments":true,"path":"2018/04/27/协商缓存/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/协商缓存/","excerpt":"","text":"浏览器缓存浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档特点：1、减少冗余的数据传输2、减少服务器负担3、加快客户端加载网页的速度 在第一次请求后，再次请求时：1、浏览器会先获取该资源缓存的header信息，根据expires和cahe-control判断是否有强缓存，若有，则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；2、如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match），由服务器根据请求中的相关header信息来对比结果是否有协商缓存，如有，则服务其返回新的响应header信息更新缓存中的对应的header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 缓存类型 获取资源形式 状态码 发送请求到服务器强缓存 从缓存取 200（from cache） 否，直接从缓存取协商缓存 从缓存取 304（Not Modified） 否，通过服务器来告知缓存是否可用 强缓存强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间 Expires该字段是http1.0的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23\\:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，就会使用缓存。这个方式的缺点就是时间是绝对时间，如果服务器和客户端时间偏差较大，就会导致缓存混乱 Cache-ControlCache-Control是http1.1时出现的header，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600s。Cache-Control除了该字段外，还有以下常用值：1、no-cache：不使用本地缓存。需要协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务器验证，如果资源未被更改，则可以避免重新下载2、no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源3、public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器4、private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存 Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到以下两组header字段，这两组搭档都是成对出现，即第一次请求的响应头带上某个字段，后续请求则会带上对应的请求字段。 Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务端返回的header中会加上Last-Modify，Last-Modify是一个时间标识资源最后修改时间，如Last-Modify: Thu,31 Dec 2037 23\\:59:59 GMT当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据最后修改时间判断资源是否更新如果未更新，则返回304，并且不会返回资源内容，并且不会返回Last-Ｍodify ETag/If-None-Match与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源时唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。 与Last-Modified不一样的是，当服务器返回304Not Modified的响应时，由于ETag重新生成过，响应头中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 为什么有ETag你可能会觉得使用Last-Modify已经足够让浏览器知道本地的缓存副本是否足够新，为什么还需要ETag呢？http1.1中ETag出现的主要是为了解决Last-Modified比较难解决的问题：1、一些文件会周期性改变，但是他的内容并不改变（仅仅是时间改变），这时候并不需要让客户端认为文件被修改了，导致重新请求（哈希，版本号，时间戳）2、某些文件修改非常频繁，比如1s修改了好多好多次，If-Modify-Since能检查到的粒度是秒级的，这种修改无法判断的3、某些服务器不能精确的得到文件的最后修改时间 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况，才会继续比对Last-Modified，最后才决定是否返回304 cache-control:immutablecache-control的新属性immutableimmutable 的推荐用法是和那些超大的 max-age 配合使用，比如 1年：Cache-Control: max-age=31536000, immutable，甚至 10年一旦被标志成 immutable，则这个资源不可能返回 304 响应了，只有 200那些带有 cached 字样的 200 请求，那些请求实际上根本不是真正的请求，只是一次本地读取文件的操作目前只支持firefox","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"双向数据绑定","slug":"双向数据绑定","date":"2018-04-27T11:27:00.000Z","updated":"2018-04-27T14:32:10.000Z","comments":true,"path":"2018/04/27/双向数据绑定/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/双向数据绑定/","excerpt":"","text":"双向绑定做法几种MVC(vm)框架都实现了单向数据绑定，双向数据绑定无非就是在单向绑定的基础上给输入元素(input、textare)添加了change、input事件，来动态修改model和view 几种实现数据双向绑定的做法：1、发布者-订阅者模式 （backbone.js）2、脏值检查 （angular.js）3、数据劫持 (vue.js) 发布者-订阅者模式： 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value) 脏值检查： angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，angular只有在指定的事件触发时进入脏值检测 数据劫持： Vue采用数据劫持结合发布者-订阅者模式的方法，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应回调 Vue双向数据绑定最核心的是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的mvvm双向绑定思路：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可以拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素结点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者 实现思路1、Observer（1）利用defineProperty来监听属性变动。 需要将Observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，这样给对象的某个值赋值，就会触发setter，就能监听到数据变化（2）现在可以监听变化了，之后要去通知订阅者，需要一个消息订阅器。 维护一个数组，这个数组就是Dep函数封装了一个数组。数据变动触发notify，这个notify定义在Dep函数的原型上。再调用订阅者的update方法，（3）之后需要能给订阅器里添加订阅者。通过Dep函数在原型上定义的添加订阅者方法，在get里面写 2、Compilecompile主要做的事情是：1、解析模板指令2、将模板中的变量替换成数据3、初始化页面视图4、并将每个指令对应的节点绑定更新数据5、添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 因为遍历操作解析的过程有多次操作DOM节点，为提高性能和效率，会先将根节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实DOM节点中compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定 关于文档碎片fragment一般js操作DOM用appendChild，但是只要append就会导致重排重绘js提供了一个DocumentFragment的机制，它可以提供一个缓冲的机制，将DOM节点先放到内存中，当节点都构造完成后，再将DocumentFragment对象添加到页面中，这时所有的节点都会一次渲染出来，这样就能减少浏览器很多的负担，明显的提高页面渲染速度通过document.createDocumentFragment这个API实现 通过递归遍历保证了每个节点及子节点都会解析编译到，包括了两个大括号表达式声明的文本节点。还有相关的v声明指令 3、WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的是：1、在自身实例化时往属性订阅器（Dep）里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并处罚Compile中绑定的回调 实例化Watcher的时候，调用get()方法，通过标记订阅者是当前Watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep里面添加当前Watcher实例，从而在属性值有变化的时候，Watcher的实例就能收到更新通知 4、MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新；视图交互变化-&gt;数据model变更的双向绑定效果","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"事件委托（事件代理）","slug":"事件委托（事件代理）","date":"2018-04-27T11:24:00.000Z","updated":"2018-04-29T14:31:10.000Z","comments":true,"path":"2018/04/27/事件委托（事件代理）/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/事件委托（事件代理）/","excerpt":"","text":"概述事件委托就是事件代理事件委托就是利用事件冒泡，指定一个处理程序，就可以管理某一类型的所有事件。 为什么要用事件委托如果有很多的DOM需要添加事件处理程序，都有相同的click点击事件，可能会用for循环方法遍历然后添加事件。 因为需要不断的与DOM节点进行交互，访问DOM的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间。 果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 事件委托原理事件委托是利用事件的冒泡原理来实现的事件冒泡：事件从最深的结点开始，然后逐步向上传播事件。事件委托就是利用冒泡到父级DOM上执行事件例：123456&lt;ul id=\"ul1\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 123456window.onload = function()&#123; var oUl = document.getElementById(\"ul1\"); oUl.onclick = function()&#123; alert(123); &#125;&#125; 这样的话，因为ul是父级，点击li，ul的事件一定会触发，这就是由于冒泡原理。 event对象提供了一个属性叫target，可以返回事件的目标结点，利用event.target就可以表示当前的事件操作的DOM，但不是真正的操作DOM。ie下是event.srcElement 这时获取的是当前节点的位置，可以通过nodeName来获取当前标签名，返回的是大写的，需要转换成小写。1234567891011window.onload = function()&#123; var oUl = document.getElementById(\"ul1\"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 如果DOM都要执行不同的函数，可以通过判断target的class或者id使用switch去绑定不同的函数。而且新加入的DOM也将具有绑定的事件 addEventListener第三个参数就是true - 事件句柄在捕获阶段执行false- 默认。事件句柄在冒泡阶段执行 addEventListener绑定的函数可以传参还可以解绑的方法12345678910111213141516var btn = document.getElementsByClassName('btn')[0], remove = document.getElementsByClassName('remove')[0];//要执行的函数var some = function (msg) &#123; console.log(msg) &#125;;//如果要执行的参数需要传入多个参数var some = function (arguments) &#123; console.log(Array.prototype.join.call(arguments,\"-\")) &#125;;var fn = some.bind(null,'哈哈');btn.addEventListener('click',fn,false);remove.addEventListener('click',function () &#123; btn.removeEventListener('click',fn,false);&#125;,false); event对象target 返回触发此事件的元素（事件的目标节点）currentTarget 返回其事件监听器触发该事件的元素","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"深拷贝","slug":"深拷贝","date":"2018-04-27T11:23:00.000Z","updated":"2018-04-27T14:32:22.000Z","comments":true,"path":"2018/04/27/深拷贝/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/深拷贝/","excerpt":"","text":"JSON对象的parse和stringifyJSON对象parse方法可以将JSON字符串反序列化成JS对象stringify方法可以将JS对象序列化成JSON字符串12345678910111213141516171819var source = &#123; name:\"source\", child:&#123; name:\"child\" &#125;&#125;var target = JSON.parse(JSON.stringify(source));//改变target的name属性target.name = \"target\";console.log(source.name); //sourceconsole.log(target.name); //target//改变target的childtarget.child.name = \"target child\";console.log(source.child.name); //childconsole.log(target.child.name); //target child 复制后的target与source是完全隔离的，二者不会相互影响。这个方法使用较为简单，可以满足基本的深复制需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深复制(而且会直接丢失相应的值)，同时如果对象中存在循环引用的情况也无法正确处理 jQuery中的extend复制方法jQuery中的extend方法可以用来扩展对象，这个方法可以传入一个参数:deep(true or false)，表示是否执行深复制(如果是深复制则会执行递归复制) 原生实现typeof和instanceof1234567891011typeof 0 // return 'number'typeof '0' //return 'string'，字符串同时也是一个类数组对象typeof false // return 'boolean'function fn()&#123; &#125;typeof fn // return 'function'var param;typeof param // return 'undefined'//ES6 新加入的类型typeof Symbol() // 'symbol' typeof在判断基本类型的时候可以，但是判断不了对象123typeof [1, 2, 3] // return 'object'typeof null // return 'object'typeof &#123;x: 1&#125; // return 'object' instanceof解决了这个问题 null和undefinednull表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。 回到instanceof A instanceof Binstanceof用来检查A的原型链上是否存在B的原型，或者直接一点说，B在不在A的原型链上1234[1, 2, 3] instanceof Array //return true null instanceof Object // return false var obj = &#123;&#125; obj instanceof Object // return true 这样就可以区分数组，null和普通对象，但是判断不了基本类型，只有通过new出来的基本类型才能通过instanceof判断 在判断是否字符串，是否数字，是否布尔值的时候，我们应该使用typeof而对数组和要判断对象是否是在某个构造函数或对象的原型链上时使用instanceof对函数的判断两者皆可。 终极boss 实现一个type函数调用Object.prototype.toString 方法。1234567891011121314151617181920function getType(obj)&#123; //tostring会返回对应不同的标签的构造函数 var toString = Object.prototype.toString; var map = &#123; '[object Boolean]' : 'boolean', '[object Number]' : 'number', '[object String]' : 'string', '[object Function]' : 'function', '[object Array]' : 'array', '[object Date]' : 'date', '[object RegExp]' : 'regExp', '[object Undefined]': 'undefined', '[object Null]' : 'null', '[object Object]' : 'object' &#125;; if(obj instanceof Element) &#123; return 'element'; &#125; return map[toString.call(obj)];&#125; 调用它123456789101112131415161718192021222324function deepClone(data)&#123; var type = getType(data); var obj; if(type === 'array')&#123; obj = []; &#125; else if(type === 'object')&#123; obj = &#123;&#125;; &#125; else &#123; //不再具有下一层次 return data; &#125; if(type === 'array')&#123; for(var i = 0, len = data.length; i &lt; len; i++)&#123; obj.push(deepClone(data[i])); //是数组就push进去 &#125; &#125; else if(type === 'object')&#123; for(var key in data)&#123; obj[key] = deepClone(data[key]); //是对象就forin赋值进去 &#125; &#125; return obj;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"浏览器渲染过程","slug":"浏览器渲染过程","date":"2018-04-27T11:23:00.000Z","updated":"2018-04-27T14:32:28.000Z","comments":true,"path":"2018/04/27/浏览器渲染过程/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/浏览器渲染过程/","excerpt":"","text":"一些引擎1、浏览器引擎：用来查询及操作渲染引擎的接口2、渲染引擎：用来查询及操作渲染引擎的接口3、UI后端：用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。4、JS解释器：用来解释执行JS代码 页面生成过程1、DNS服务器通过域名查找对应的Web服务器ip地址2、浏览器访问Web服务器（三次握手）3、服务器处理完成 返回html4、浏览器解析、加载页面 解析html构建dom树 -&gt; 构建渲染树 -&gt; 布局渲染树 -&gt; 绘制渲染树 浏览器为了体验友好，并不是文档全部都解析才绘制到屏幕上，而是从上至下开始解析html，遇到css 会开启线程下载css解析：1、将html构建成一个DOM树，DOM树的构建过程是一个深度遍历过程：当前结点的所有子节点都构建好后才会去构建当结点的下一个兄弟结点2、将css解析成css去构造cssom树（cssom=css对象模型）3、根据DOM树和cssom来构造渲染树。渲染树并不等同于DOM树，因此一些像Header或者display:none的东西就不会出现在渲染树中。4、有了渲染树，浏览器已经能知道网页中有哪些结点、各个节点的css定义以及他们的从属关系5、下一步操作会是布局，顾名思义就是计算每个节点在屏幕中的位置布局渲染树6、绘制，遍历渲染树，并使用浏览器UI后端层绘制每个节点 性能优化中重绘、重排（1）Reflow（回流/重排）：当它发现了某个部分发生了变化影响了布局，渲染树需要重新计算。（2）Repaint（重绘）：改变了某个元素的背景颜色、文字颜色等。不影响元素周围或内部布局的属性，将只会引起浏览器的重绘，根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会重新布局，并不一定伴随重排 上面的有点乱：1、浏览器接收到html代码，自上而下解析：构建DOM树+构建css对象模型=》渲染树2、遇到script文件和css文件都会另起线程去下载；内嵌的script标签和style标签，会直接执行，分别阻塞DOM树和css规则树3、无论内嵌的script脚本、外链的script脚本下载都会阻塞构建DOM树；css文件执行和内嵌的style标签阻塞css对象模型4、直到DOM树和css对象模型规则生成完毕后，浏览器结合两者生成渲染树，浏览器将渲染树绘制到页面上，首次显示页面5、最后body底部的JS脚本下载完成后通过DOM API修改DOM，通过css对象模型 API修改样式，每次修改都会造成渲染树的重排和重绘。 注意1、把js放在body之后，是为了预防外部js文件过多，浏览器呈现页面出现延迟，延迟期间浏览器的窗口一片空白2、当遇到script文件加载/执行会阻塞后面DOM树的构建（因为js可能会改变DOM树）而遇到css文件则会阻塞渲染树的构建，即DOM树依然继续构建（除非遇到script标签并且css文件依旧未加载完成），但不会渲染绘制到页面上。而无论哪个阻塞，该加载的文件还是会加载，例如html文档中的其他css/js/图片文件3、js脚本放在head和body有什么区别head中的脚本会在页面加载之前解析，可以保证脚本在任何调用之前被加载body中的脚本会在页面加载完成之后读取，放在body部分的脚本通常被用来生成页面的内容。因为加载js脚本会阻塞页面的加载，为了用户体验也为了脚本可以正常操作DOM，一般放在body中浏览器解析html是从上到下的如果把js放在head里的话，则先被解析，但这时候body还没有解析，所以会返回空值。一般都会绑定一个监听，当全部的html文档解析完之后，在执行代码：windows.onload 总之：内嵌和外链js脚本，都会阻塞DOM树的构建；style标签和css文件，都会阻塞css对象模型的构建 1、计算CSS样式2、构建Render Tree3、Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性4、正式开画 Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow ）reflow 会从html这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。 导致重排1、当你增加、删除、修改DOM结点时，会导致Reflow或Repaint2、当你移动DOM的位置，或是搞个动画的时候。3、当你修改CSS样式的时候。4、当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。5、当你修改网页的默认字体时。 优化办法：1、不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className2、不要把DOM结点的属性值放在一个循环里当成循环里的变量3、为动画的DOM使用fixed或absolute的position：不会重排，脱离文档流4、不使用table布局：table中一个小的改动会造成整个table的重新布局 script的async和defer属性async，立即下载，异步操作，即合加载和渲染后续文档元素的过程并行进行，也就是异步，一起操作defer，立即下载，延迟解析，可以延迟到文档完全被解析和显示之后再执行 相同点：1、加载文件时不阻塞页面渲染2、使用这两个属性的脚本中不能调用document.write方法3、允许不定义属性值，仅仅使用属性名不同点：1、支持程度不一样async是h52、每一个async属性的脚本都在它下载结束之后立即执行，同时会在window的load事件之前执行，所以就有可能出现脚本执行顺序被打乱的情况3、每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"跨域","slug":"跨域","date":"2018-04-27T09:22:00.000Z","updated":"2018-04-27T14:32:42.000Z","comments":true,"path":"2018/04/27/跨域/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/跨域/","excerpt":"","text":"同源策略同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口“三者相同，即便两个不同的域名指向同一个ip地址，也非同源。同源策略限制以下几种行为：1.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送 跨域总结1、jsonp2、document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、postMessage跨域6、跨域资源共享（CORS）7、nginx反向代理8、node中间件跨域代理9、WebSocket协议跨域 jsonp123456789101112var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/loginuser=admin&amp;callback=onBack'; // 添加script标签 document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; 后台需要获取回调函数名，然后返回json格式数据缺点：只能get，需要保证请求的目的地的绝对安全 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域document.domain = ‘同一主域’子窗口通过window.parent.xx获取父窗口定义的变量 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB） 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：1、页面和其打开的新窗口的数据传递2、多窗口之间消息传递3、页面与嵌套的iframe消息传递用法：postMessage(data,origin)方法接受两个参数，接收通过监听message事件实现data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*“，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。（设置httponly防止js操作cookie） 前端：xhr.withCredentials = true;后台：’Access-Control-Allow-Credentials’: ‘true’ 后端允许发送 ‘Access-Control-Allow-Origin’：* 允许访问的域 nginx代理跨域nginx反向代理接口跨域 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 原理：同源策略是浏览器的安全策略，不是http协议的一部分。服务器端调用http接口只是使用http协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 代理服务器server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。利用node + express + http-proxy-middleware搭建一个proxy服务器。1234567891011121314151617181920var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改&#125;));app.listen(3000);console.log('Proxy server is listen at port 3000...'); WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 一个websocket请求GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 告诉服务器Upgrade更换协议 响应HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 服务器响应，协议切换成功","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"浏览器多进程和JS单线程（硬件加速）","slug":"浏览器多进程和JS单线程","date":"2018-04-27T09:22:00.000Z","updated":"2018-04-30T14:03:02.000Z","comments":true,"path":"2018/04/27/浏览器多进程和JS单线程/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/浏览器多进程和JS单线程/","excerpt":"","text":"进程和线程区别进程：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）线程：线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 浏览器是多进程的1、浏览器是多进程的2、浏览器之所以能够运行，是因为系统给他的进程分配了资源（cpu、内存）3、每次打开一个Tab页，就相当于创建了一个独立的浏览器进程 浏览器有哪些进程1、浏览器进程：浏览器的主进程（负责协调、主控），只有一个，作用： （1）负责浏览器界面显示，与用户交互。如前进后退 （2）负责各个页面的管理，创建和销毁其他进程 （3）绘制到用户界面上 （4）网络资源的管理，下载等2、第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建3、GPU进程：最多一个，用于3D绘制等4、浏览器渲染进程：每个页面一个进程，互不影响。主要控制页面渲染，脚本执行，事件处理等 浏览器多进程优势如果浏览器是单线程，如果某个Tab页崩溃了，就影响了整个浏览器，体检就很差。如果是单线程，插件崩溃了也会影响整个浏览器 浏览器内核！important主要常驻线程：1、GUI渲染线程 （1）负责渲染浏览器界面，解析HTML，CSS，构建DOM树和渲染对象树，布局和绘制等 （2）当界面需要重绘或由于某种操作引发回流时，该线程就会执行 （3）注意，GUI渲染线程与JS引擎线程是互斥的，当引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行2、JS引擎线程 （1）也成为JS内核，负责处理JS脚本程序，JS引擎负责解析JS脚本，运行代码 （2）JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（即是一个渲染进程）中无论什么时候都只有一个JS线程在运行JS程序 （3）GUI渲染线程和JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞3、事件触发线程 （1）归属于浏览器而不是JS引擎，用来控制事件循环（注意是浏览器另开的线程协助） （2）当JS引擎执行代码块如setTimeout时（也可能是来自浏览器内核的其他线程，如鼠标点击，AJAX异步请求等），会将对应人物添加到事件线程中 （3）当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 （4）由于JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理（JS引擎空闲时候才会去执行）4、定时触发线程 （1）传说中的setInterval和setTimeout所在的线程 （2）浏览器定时计数器并不是由JS引擎计数的，（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时器的准确性） （3）因此通过单线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） （4）W3C规定setTimeout有最小时间间隔4ms5、异步http请求线程 （1）XHR在连接后是通过浏览器新开一个线程请求 （2）将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调函数再放入事件队列中。再由JS引擎执行 关于JS单线程和事件（任务）队列任务两种：同步、异步同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务异步任务：不进入主线程、而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行 异步执行机制：1、所有同步任务都在主线程上执行，形成一个执行栈2、主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件3、一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。4、主线程不断重复上面操作 event loop主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 主线程运行的时候，产生堆和栈，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done）。只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。 定时器除了放置异步任务的事件，“任务队列”还可以放置定时器事件，即指定某些代码在多少时间之后执行。定时器中回调执行的代码永远在其他代码执行之后，因为他被放到了事件队列中，只有主线程执行完之后才会执行“任务队列”中的回调函数总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 Node的 Event LoopNode提供了process.nextTick和setImmediateprocess.nextTick方法可以在当前“执行栈”的尾部————下一次Event Loop（主线程读取“任务队列”）之前————触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。他总比时间队列里快，比setTimeout永远快setImmediate方法则是在当前“任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行。和setTimeout(fn, 0)很像process.nextTick和setImmediate的一个重要区别多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。 实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！process.nextTick(function foo() { process.nextTick(foo);}); 浏览器控制进程和浏览器内核的通信上面扯了事件队列，再回到浏览器里 浏览器两个进程：一个主控进程，一个打开Tab页的渲染进程 1、控制进程收到用户请求，首先需要获取页面的内容，随后将该任务通过接口传给渲染进程2、渲染进程的渲染接口收到消息，简单解释后，交给渲染线程，然后开始渲染 （1）渲染线程开始渲染，加载网页并渲染页面。其中需要控制进程获取资源和需呀GPU进程来帮助渲染 （2）会有JS线程操作DOM，这样造成重排重绘 （3）最后渲染进程将结果传给控制进程3、控制进程接收到结果并将结果绘制 整理一下之间的关系GUI渲染线程与JS引擎线程互斥由于JS是可操作DOM的，如果在修改这些元素属性同时渲染界面，或者说JS线程和UI线程同时运行，那么渲染线程前后获得的元素数据可能不一致了因为为了防止渲染出现不可预估的结果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行 JS阻塞页面加载从上可见，JS如果执行时间过长就会阻塞页面假如JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存在队列中，等到JS引擎空闲后执行，然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉 可以使用webWorker去进行巨量计算，关于webWorker1、创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）2、JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 再梳理一下渲染流程1、解析html构建DOM树2、解析css构建render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）3、布局render树（Layout\\reflow），负责各元素尺寸、位置的计算4、绘制render树（paint），绘制页面像素信息5、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 load事件与DOMContentLoaded事件的先后1、当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 2、当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了） css加载是否会阻塞dom树渲染？1、头部引入csscss是单独的下载线程异步现在的 （1）css加载不会阻塞DOM树解析（异步加载时DOM照常构建） （2）但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 EventLoop几个线程：1、JS引擎线程2、事件触发线程3、定时器触发线程 几个概念：1、JS分为同步任务和异步任务2、同步任务都在主线程上执行，形成一个执行栈3、主线程之外，事件触发器线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件4、一旦执行栈中所有的同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行 定时器线程有单独的定时器线程定时器线程是将事件于多少时延后放入事件队列，主线程没任务后会在EventLoop机制的情况下去执行事件队列中的定时器的回调函数setInerval有累计效应，如果setInterval再次添加到队列之前其他的事件还么执行完，就会导致定时器代码连续运行好几次，而之间没有时间间隔。就算正常运行，多个setInterval的代码执行时间可能会比与其的小（因为代码执行需要一定时间） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 Promise和事件循环机制Promise会先比setTimeout执行有两种新的任务类型：macrotask和microtaskmacrotask：宏任务（task）。每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） （1）每个task会从头到尾将这个任务执行完毕，不会执行其他 （2）浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染（task-&gt;渲染-&gt;task-&gt;…）microtask：微任务（jobs）。当前task执行结束后立即执行的任务 （1）也就是说，在当前task任务后，下一个task之前，在渲染之前 （2）所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 （3）也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别很么样的场景会形成macrotask和microtask呢？macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。另外，setImmediate则是规定：在下一次Event Loop（宏任务）时触发（所以它是属于优先级较高的宏任务）， （Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面）， 所以setImmediate如果嵌套的话，是需要经过多个Loop才能完成的， 而不会像process.nextTick一样没完没了。 macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 机制总结1、执行一个宏任务（栈中没有就从事件队列中获取）2、执行过程中如果遇到微任务，就将他添加到微任务的任务队列中3、宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）4、当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染5、渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"垃圾回收、基本类型、引用类型","slug":"垃圾回收、基本类型、引用类型","date":"2018-04-27T09:22:00.000Z","updated":"2018-04-29T09:30:08.000Z","comments":true,"path":"2018/04/27/垃圾回收、基本类型、引用类型/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/垃圾回收、基本类型、引用类型/","excerpt":"","text":"基本类型和引用类型的值js变量是松散类型，所谓松散类型就是可以保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。由于不存在定义某个变量必须要保存任何数据类型值的规则，变量的值及数据类型可以在脚本的生命周期内改变。基本类型是指简单的数据段，引用类型是指那些可能由多个值构成的对象5种基本数据类型：Undefined、Null、Boolean、Number和String。这五种基本类型是按值访问的，因为可以操作保存在变量的实际的值。引用类型的值是保存在内存中的对象。与其他语言不同，js不允许访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。引用类型的值是按引用访问的，但是在为对象添加属性时，操作的是实际的对象。 基本类型的复制，被赋值是新的变量，之后互不干扰而引用类型，在赋值时，新的变量放到新的空间，但是这个值的副本实际上是一个指针。因此，改变一个变量，就会影响另一个对象。1234var obj1 = new Object();var obj2 = obj1;obj1.name = \"xx\";alert(obj2.name); // xx js所有函数的参数都是按值传递的。 typeof null =&gt; object所有引用类型都是Object的实例，instanceof任意一个引用类型都是true，比如array instanceof Object;但是检测不了基本类型。 每个函数都有一个执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其执行环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中执行流是由这样一个机制控制着。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象即arguments对象。 js没有块级作用域，if、for花括号后括号内的声明依然保留 垃圾回收机制js垃圾回收机制：找出那些不在继续使用的变量，然后释放其占用的内存。垃圾回收机制会按照固定的时间间隔，周期性的执行操作。通常的垃圾回收策略：1、标记清除：在垃圾回收机制运行的时候给存储在内存中的所有变量都加上标记。如果有被引用的变量，则清除掉标记。还有标记的被清除，收回它们所占的内存空间。2、计数引用跟踪记录每个值被引用的次数。声明的时候是1，在赋值给其他变量是为2，被赋值的变量得到另一个值，引用次数为1。引用次数变成0的时候，就清除。但是会有循环引用的情况，导致永远不为0。在ie7-中，垃圾回收机制是根据内存分配量运行的，达到固定的临界值，再运行GC机制。问题在于，如果脚本中有大量的变量，会导致GC一直在运行。之后的ie采用了动态计算临界值的方法。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"继承","slug":"继承","date":"2018-04-27T09:19:00.000Z","updated":"2018-04-27T14:33:22.000Z","comments":true,"path":"2018/04/27/继承/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/继承/","excerpt":"","text":"组合继承为什么好1、为什么不在原型中定义了属性（不单独使用原型链的原因）包含引用类型的原型属性会被所有实例共享，所以要在构造函数中，而不是在原型对象中定义属性的原因。就是如果在构造函数的原型中定义了属性，在实例化之后，实例操作属性时，就会改变这些属性，并且导致其他实例的属性也改变。没有办法在不影响所有对象实例的情况下，给超类型的构造函数传参。 2、借用构造函数技术思想：在子类型构造函数的内部调用超类型构造函数，使用apply和call在创建的对象上执行构造函数。把新创建的对象作为构造函数。在新的构造函数中，给先前的构造函数传参，这样的属性不会被重写但是，这样的话方法都会在构造函数中定义，这样就就不能函数复用。而且超类的方法在子类不可见，结果所有类型都只能使用构造函数模式。 3、组合继承！！将原型链和借用构造函数的技术结合。在构造函数来实现对实例属性的继承，保证了实例有自己的属性。在原型上定义方法实现了函数的复用 123456789101112131415161718192021222324function SuperType(name)&#123; this.name = name; this.colors = ['r', 'b', 'g'];&#125;function.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //继承属性 this.age = age;&#125;SubType.prototype = new SuperType(); //继承方法SubType.prototype.constructor = SubType;SubType.prototype = function()&#123; alert(this.age);&#125;;var instance = new SubType(\"xx\", 20);instacne.color.push(\"k\");alert(instance.colors); //r,g,b,kinstance.sayName(); //xxinstance.sayAge(); //20 new时都发生了什么1、创建了一个新对象 var obj = {}2、将构造函数中的this关键字指向obj3、将构造函数的prototype原型指向obj原型，这样obj就拥有了构造函数中的方法4、执行构造函数的代码12345678910111213141516function Animate(name)&#123; this.name = name;&#125;Animate.prototype.dance = function()&#123; console.log(this.name + \"在跳舞！\");&#125;var dog = new Animate('小白');dog.dance(); var obj = &#123; name : '小白', dance : function()&#123; console.log(this.name + \"在跳舞！\"); &#125; &#125; 1.创建了一个新对象 var obj = {}2.将Animate中的this关键字指向obj3.将Animate的prototype原型指向obj原型,这样obj就拥有了Animate中的方法4.执行Animate构造函数（类)的代码","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"进程线程区别","slug":"进程线程区别","date":"2018-04-27T09:19:00.000Z","updated":"2018-05-07T08:47:22.000Z","comments":true,"path":"2018/04/27/进程线程区别/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/进程线程区别/","excerpt":"","text":"进程和线程都是一个时间段的描述，是CPU工作时间段的描述。 进程和线程的区别：1、进程是资源分配和调度的一个独立单元，线程是CPU调度的基本单元2、同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程3、进程的结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他的其他线程的结束4、线程是轻量级的进程，它的创建和销毁所需要的时间比进程中小很多，所有操作系统中的执行功能都是创建线程去完成的5、线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源 进程进程控制块（PCB）进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位 进程创建时，为该进程生成一个PCB；进程终止时，回收PCB。PCB由链表实现（为了动态插入和删除） PCB包含信息：1、进程状态（state）；2、进程标识信息（uid、gid）；3、定时器（time）；4、用户可见寄存器、控制状态寄存器、栈指针等（tss） 每个进程都有一个非负的唯一进程ID（PID）。虽然是唯一的，但是PID可以重用，当一个进程终止后，其他进程就可以使用它的PID了。PID为0的进程为调度进程，该进程是内核的一部分，也称为系统进程；PID为1的进程为init进程，它是一个普通的用户进程，但是以超级用户特权运行；PID为2的进程是页守护进程，负责支持虚拟存储系统的分页操作。 死锁概念：相互等待资源而产生的一种僵持状态，如果没有外力干预将一直持续这个状态死锁的原因：资源不足、相互竞争资源、循环等待、请求与保持死锁的必要条件：互斥、不可抢占、循环等待、请求与保持处理死锁：因为互斥不可改变，所以只能破坏其他三个条件中的一个来解除死锁处理方法：剥夺资源、杀死其中一个线程 进程的集中状态1、run（运行状态）：正在运行的进程或在等待队列中等待的进程，等待的进程只要得到CPU就可以运行2、sleep（可中断休眠状态）：相当于阻塞或在等待的状态3、D（不可中断休眠状态）：在磁盘上的进程4、T（停止状态）：这中状态无法直观的看见，因为是进程停止后就释放了资源，所以不会留在linux中5、Z（僵尸状态）：该进程本应该已经执行完毕，但是该进程的父进程却无法完整的将该进程结束掉，而造成该进程一直存在于内存中 线程是程序执行流的最小单元线程也有就绪、阻塞和运行三种基本状态","categories":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}],"tags":[{"name":"闲聊","slug":"chat","permalink":"https://qiaoding18.github.io/tags/chat/"}],"keywords":[{"name":"chat","slug":"chat","permalink":"https://qiaoding18.github.io/categories/chat/"}]},{"title":"WebSocket相关","slug":"WebSocket相关","date":"2018-04-27T09:17:00.000Z","updated":"2018-04-29T09:28:20.000Z","comments":true,"path":"2018/04/27/WebSocket相关/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/WebSocket相关/","excerpt":"","text":"首先WebSocket是全双工的，通信双方建立起一个保持在活动状态的连接通道 WebSocket协议是借用http协议的101状态码 协议更换请求头的upgrade实现协议更换 WebSocket协议是基于Frame而非Stream的，也就是说，数据的传输不是像传统数据流读写一样按字节发送，而是采用一帧一帧的Frame，每个Frame都定义了严格的数据结构，因此所有的信息就在这个Frame载体中 特点 基于TCP协议 具有命名空间 可以和HTTP Server共享同一port 连接过程1、首先需要浏览器主动发起一个HTTP请求，请求头中Upgrade内容为WebSocket，2、一旦服务器收到来自客户端的upgrade请求，便会将请求头中的“Sec-WebSocket-Key”字段提取出来，追加一个固定的串，3、之后将字段内容（编码的随机字符串）加上那个串，加密并生成一个新的key，作为响应头中的“Sec-WebSocket-Accept”字段的内容返回给浏览器4、浏览器接收到来自服务器的响应，便会解析响应中的“Sec-WebSocket-Accept”字段，与自己加密后的串比对，匹配成功就建立连接 安全性连接建立时：WebSocket协议规定在连接建立时检查Upgrade请求中的某些字段（如Origin），对于不符合要求的请求立即截断 通信过程中：也对Frame中的控制做了很多限制，以便禁止异常连接 和TCP、HTTP协议的关系WebSocket是基于TCP的独立的协议和HTTP的唯一关联就是HTTP服务器需要发送一个Upgrade请求，即101 Switching Protocol到HTTP服务器，然后由服务器进行协议转换。 关闭连接主动关闭端会发送Close Frame关闭帧，一端接收到Close Frame，并也发送过Close Frame时，就可以关闭连接了然后底层TCP连接关闭，连接状态变为closed关闭成功后状态是clean close","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"布局","slug":"布局","date":"2018-04-27T09:17:00.000Z","updated":"2018-04-29T09:29:38.000Z","comments":true,"path":"2018/04/27/布局/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/布局/","excerpt":"","text":"元素分类行内元素a, b, span, img, input, strong, select 块级元素div, ul, ol, li, dh, dt, p, h1, h2 空元素br, hr, img, input, link, meta 行内元素和块级元素的区别1、行内元素会在一行内并排显示，块级元素会占一行显示2、块级元素可以包含行内元素，行内元素不能包含块级元素3、行内元素width无效，height无效（需设置line-height），margin上下无效，padding上下无效，行内元素宽高由内容决定，可以显示出效果，但是竖直方向的内边距只有效果，对其他元素无任何影响。 4、替换元素一般有内在尺寸，所以具有width和height，可以设定 相互转换块级元素转行内元素：display:inlne;元素被显示为内联元素，宽高无效，不独占一行。display:inline-block;元素为行内块元素，有宽高属性，但不独占一行。行内元素转块级元素：display:block;元素有宽高属性，并独占一行显示 div与table的优缺点div优点1、页面布局灵活2、代码简洁3、标准化页面结构 div缺点1、可读性差2、兼容性差，开发时把不同浏览器样式都考虑进去 table优点1、可读写性，语句编写方便2、兼容性好 table缺点1、代码冗余2、网页打开速度慢 盒模型内边距padding对于行内元素，左内边距应用到元素的开始处，右内边距应用到元素的结尾处，垂直内边距不影响行高，但会影响自身尺寸1、上下内边距不影响行内元素2、内边距不能是负值3、块级元素可以通过padding:50%实现正方形效果，因为水平垂直的padding的百分比值都由包含块的宽度决定4、所有浏览器的input、textarea、button都有内置的padding 外边距margin设置外边距margin会在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景1、上下外边距对行内元素的宽高没有任何影响2、可以为负数3、会重叠，发生在块级元素的垂直方向 边框border元素外边距内就是元素的边框border，元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成对于行内元素来说，边框实际上画在各行之外的下一个像素上，由于各行紧挨着，所以其边框会重叠。无论为行内元素的边框设置怎样的宽度，不会对行高有任何影响；但左右边框会分别显示在元素的开始处和结尾处 box-sizing在CSS中盒模型被分为两种，第一种是W3C的标准模型，第二种是IE怪异盒模型。不同之处在于后者的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸。目前对于浏览器大多数元素都是基于W3C标准的盒模型，但对于表单form中的部分元素还是基于IE的怪异盒模型，如input里的radio、checkbox、button等元素，如果给其设置border和padding它们也只会往元素盒内延伸 在W3C的标准模型下，宽度和高度仅仅包含了内容宽度，除去了边框和内边距两个区域，这样为web设计师处理效果带来了不少麻烦。为了解决这个问题，CSS3新增了一个盒模型属性box-sizing，能够事先定义盒模型的尺寸解析方式box-sizing:border-box;让宽度=内容（padding）+边框 position布局四种属性：static、relative、absolute、fixed默认是static，有根没有一样，static时top啥了的不管用设置z-index时，父子元素无法通过z-index比较，除非子元素z-index为负值 relative1、relative会导致自身位置的相对变化，而不会影响其他元素的位置、大小变化2、relative产生一个新的定位上下文3、并没有改变行内元素的display属性4、如果同时设置了relative和float，则元素先浮动到相应的位置，然后再根据top啥了的所设置的距离发生偏移5、并没有脱离文档流 absolute1、脱离文档流，导致父元素塌陷，并改变了display属性2、使原先的行内元素变为块级元素3、添加了absolute后元素依然在原先的位置4、会悬浮在页面上方，会挡住下面的内容5、会使float失效哦6、多个重叠，后来居上7、如果给absolute设置了top、left，浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位 fixed其实fixed和absolute是一样的，唯一的区别在于：absolute元素是根据最近的定位上下文确定位置，而fixed永远根据浏览器确定位置。 stickyposition属性中最有意思的就是sticky了，设置了sticky的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。有种粘在视口中的感觉。1、该元素并不脱离文档流，仍然保留元素原本在文档流中的位置2、当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。3、元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 生效条件：1、一个是元素自身在文档流中的位置2、另一个是该元素的父容器的边缘 ff safai支持 float布局float被设计出来的初衷是用于文字环绕效果1、float脱离文档流，破坏了父标签原本的结构，使父标签塌陷。2、设置了float，行内元素会变为块级元素 清除浮动1、为父元素添加overflow:hidden2、浮动父元素3、浮动的兄弟元素添加clear:both;4、clearfix1234&lt;div class=\"clearfix\"&gt; &lt;img src=\"xx\" style=\"float:left\"&gt; &lt;img src=\"oo\" style=\"float:left\"&gt;&lt;/div&gt; 12345678.clearfix:after&#123; content: ''; display: block; clear:both;&#125;.clearfix&#123; *zoom: 1; // 兼容IE低版本&#125; BFCBFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level Box参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。BFC 区域，不会与浮动元素重叠。 BFC的生成 float的值不为none； overflow的值不为visible； display的值为inline-block、table-cell、table-caption； position的值为absolute或fixed；满足一个条件就生成BFC 居中水平居中 要居中的元素为行内元素，给其父元素设置text-align:center; 要居中的元素为块级元素，给元素本身设置margin:0 auto; 绝对定位position:absolute; width:固定;left:50%;margin-left:-0.5宽度; 绝对定位position:absolute; width:固定;left:50%;margin:0 auto; css3中的transform属性position:absolute; left:50%; transform:translate(-50%, 0); flex布局给父元素设置display:flex; justify-content\\:center; 垂直居中 单行文本可设置line-height等于父元素高度 vertical-align:middle;只有在父层为td或者th时才会生效。其他情况下需要设置父元素display:table;子元素display:table-cell;verical-align:middle; 这样子元素的高度自适应不用设置； 绝对定位position:absolute; top:50%; transform:translate(-50%, -50%); 绝对定位position:absolute; top:50%; height:固定; margin-top:-0.5高度; 常用的一种 parent::after,son{ display:inline-block;vertical-align:middle; } parent::after{ content:’’;height:100%; } flex父元素设置display:flex; align-items:center; 两栏布局1、左边：float:left; width:固定;右边：margin-left:左边宽度;2、左边：float:left; width:固定;右边：overflow:auto; 生成个BFC 三栏布局1、左边：float:left;右边：float:right;中间：margin-left:左宽度;margin-right:右宽度;中间的DOM必须写在另外两个的html文档位置后面2、左边：float:left;右边：float:right;中间：overflow:hidden;BFC 区域，不会与浮动元素重叠。3、圣杯布局父级：padding: 0 右边宽度 0 左边宽度;中间：float:left; width:100%; height:随意;左边：float:left; position:relative; width:左边宽度; margin-left:-100%; left:-左边宽度; height:随意;右边：float:left; position:relative; width:右边宽度; margin-left:-右边宽度; right:-右边宽度; height:随意;4、双飞翼布局中间：float:left; width:100%; height:随意;中间子元素：padding:0 右边宽度 0 左边宽度;左边：float:left; width:左边宽度; margin-left:-100%; height:随意;右边：float:left; width:右边宽度; margin-left:-右边宽度; height:随意;5、Flex父级：display:flex;中间：flex:1;两边：flex-basis:需要的宽度 （是flex的第三个简写项）左边：order：-1； flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。Flex第一项flex-grow为1就是自动填充放缩它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Webpack","slug":"Webpack","date":"2018-04-27T09:16:00.000Z","updated":"2018-04-29T09:26:46.000Z","comments":true,"path":"2018/04/27/Webpack/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Webpack/","excerpt":"","text":"Webpack概念WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 webpack可以实现 开发 和 测试 环境 四个核心：入口（entry）、出口（output）、module（模块加载器）、插件（plugins） entry入口入口，指示webpack应该使用哪个模块 来作为构建内部依赖图的开始。进入入口起点后，webpack会找出哪些模块和库是入口起点（直接和间接）依赖的在entry中可以设置一个或多个入口，多个入口时在entry对象里添加多个入口属性1234entry: &#123; app: './src/app.js', vendors: './src/vendors.js'&#125; output出口output属性告诉webpack在哪里输出它所创建的bundles，以及如何命名这些文件。可以设置path、filename属性1234output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js'&#125; loader(module)loader让webpack能够去处理那些非js文件（webpack本身只理解js）。loader可以将所有类型的文件转换为webpack能够处理的有效模块本质上，webpack loader将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块在更高层面，webpack的配置中loader有两个目标 1、识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性)2、转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性) 12345module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ]&#125; 在rule中必须包括test和use，告诉编译器：“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。 插件 pluginsloader被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。想要使用一个插件，需要require它，然后把它添加到plugins数组中。多数插件可以通过选项（option）自定义。你也可以在一个配置文件中因为不同的目的而多次使用同一个插件，这时需要使用new操作符来创建它的一个实例1234plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)] 实时预览webpack的监听模式，当文件变化时重新执行，执行完后通知DevServer。devserver会让webpack在构建出的JS代码里注入一个代理客户端用于控制网页，网页和DevServer之间通过Websocket协议通信，以方便DevServer主动向客户端发送命令。DevServer在收到来自webpack的文件变化通知时通过注入的客户端控制网页刷新 模块热替换模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 Entrycontextwebpack在寻找相对路径的文件时会以context为根目录，context默认会执行启动webpack时所在的当前工作目录。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Vue虚拟DOM","slug":"Vue虚拟DOM","date":"2018-04-27T09:15:00.000Z","updated":"2018-04-29T14:34:00.000Z","comments":true,"path":"2018/04/27/Vue虚拟DOM/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Vue虚拟DOM/","excerpt":"","text":"DOM是文档对象模型的简写，在浏览器中我们可以通过JS来操作DOM，但是这样的操作性能很差，于是虚拟DOM应运而生。 虚拟DOM就是在JS中模拟DOM对比树来优化DOM操作的一种技术或思路 VNode虚拟DOM对象包含了哪些属性 tag：当前结点的标签名 data：当前结点的数据对象，有一大堆 children：数组类型，包含了当前结点的子节点 text：当前结点的文本，一般文本节点或注释结点会有这个属性 elm：当前虚拟结点对应的真实的DOM结点 ns：结点的namespace context：编译作用域 functionalContext：函数化组件的作用域 key：节点的key属性，用于作为结点的标识，有利于patch的优化 child: 当前节点对应的组件实例 parent: 组件的占位节点 isStatic: 静态节点的标识 isRootInsert: 是否作为根节点插入，被transition包裹的节点，该属性的值为false isComment: 当前节点是否是注释节点 isCloned: 当前节点是否为克隆节点 isOnce: 当前节点是否有v-once指令 VNode分类VNode可以理解为vue框架的虚拟DOM的基类，通过new实例化的VNode大致可以分为几类 EmptyVNode：没有内容的注释结点 TextVNode：文本节点 ElementVNode：普通元素节点 ComponentVNode：组件节点 CloneVNode：克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true patch原理patch函数接收6个参数 oldVnode：旧的虚拟结点或旧的真实DOM节点 vnode：新的虚拟结点 hydrating：是否要跟真实DOM混合 parentElm：父节点 refElm：新节点将插入到refElm之前 patch的策略1、如果vnode不存在但是oldVnode存在，说明意图是要销毁老节点，那么就调用API来销毁旧的结点2、如果oldVnode不存在但是vnode存在，说明意图是要创建新节点，那么就调用createElm来创建新节点3、当vnode和oldVnode都存在时 * 如果oldVnode和vnode是同一个节点，就调用patchVnode来进行patch * 当vnode和oldVnode不是同一个节点时，如果oldVnode是真实dom节点或hydrating设置为true，需要用hydrate函数将虚拟DOM和真实DOM进行映射，然后将oldVnode设置为对应的虚拟DOM，找到oldVnode.elm的父节点，根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置 总结一下1、新虚拟DOM不存在，旧的存在，就说明要删除旧的了2、旧虚拟DOM不存在，新的存在，就说明要创建新的了3、新旧虚拟DOM都存在： （1）是同一个节点，调用patchVnode （2）不是同一个节点，如果是真实DOM，就将虚拟DOM映射和真实DOM进行映射，然后把oldVnode设置为对应的虚拟DOM，找到父节点，新的真实DOM节点并插入到该父节点中 重点是patchVnode函数，因为真正的patch算法是由它来实现的（patchVnode中更新子节点的算法其实是在updateChildren函数中实现的） patchVnode算法1、如果oldVnode跟vnode完全一致，不做任何事情2、如果oldVnode跟vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把新的相关属性赋值到vnode上3、如果不是文本或注释节点，两者都有子节点，且子节点不完全一致，就需要更新子节点的操作，更新操作通过比较oldStartVnode和newStartVnode的属性，属性进行patch操作4、如果只是文本或注释结点，只需更新文本内容 虚拟DOM的生命周期1、init：虚拟DOM初始化时2、create：虚拟DOM创建时3、prepatch：patch之前4、insert：虚拟DOM插入后5、update：虚拟DOM更新前6、postpatch：patch之后7、remove：虚拟DOM除移时8、destroy：虚拟DOM销毁时 vue组件的声明周期底层其实就是依赖于虚拟DOM的生命周期，vue为自己的组件虚拟DOM已经写好了默认的init/prepatch/insert/destroy。而vue组件的mounted/activated就是在insert中触发的，deactivated就是在destroy中触发的","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Vue-router ","slug":"Vue-router","date":"2018-04-27T08:47:00.000Z","updated":"2018-04-27T14:33:58.000Z","comments":true,"path":"2018/04/27/Vue-router/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Vue-router/","excerpt":"","text":"概述使用router-link组件来导航通过to属性指定链接还有一个路由出口，把路由匹配到的组件渲染在里面12345678910111213&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)123456789101112131415161718192021222324252627// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 还是概述路由的三个基本概念route，routes，router1、route它是一条路由，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。2、routes是一组路由，把上面的每一条路由组合起来，形成一个数组，[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]3、router是一个机制，相当于一个管理者，它来管理路由。因为routes只是定义了一组路由，它放在哪里是静止的，当真正来了请求，就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容4、客户端中的路由，实际上就是DOM元素的显示和隐藏。当页面中显示home内容的时候，about中的内容全部隐藏，反之也一样。客户端路由有两种实现方式：基于hash和基于history api vue-router中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来 hash模式和history模式hash模式hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件hash发生变化的URL都会被浏览器记录下来，从而使浏览器的前进后退都可以用。这样尽管浏览器没有请求服务器，但是页面状态和URL一一关联起来，这就是前端路由，单页面应用的标配只能改变#后的url，在请求时也不会带上#后的内容 history路由随着history api的到来，前端路由开始进化了，前端的hashchange，只能改变#后面的URL片段，history api则给了前端完全的自由 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求 切换历史状态包括back，forward，go三个方法，对应浏览器的前进，后退，跳转操作history.go(-2) 后退两次history.go(2) 前进两次history.back() 后退history.forward() 前进 修改历史状态包括pushState，replaceState两个方法，这两个方法接受三个参数stateObj，title，url 通过history.pushstate把页面的状态保存在第一个参数state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到state的里面。history丢掉了#，但如果刷新，就回去请求服务器 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时不会携带。在history下，可以自由修改path，当刷新时，如果服务器中没有响应或者资源，会导致404","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"TCP UDP OSI参考模型","slug":"TCP-UDP-OSI参考模型","date":"2018-04-27T08:45:00.000Z","updated":"2018-04-27T14:31:14.000Z","comments":true,"path":"2018/04/27/TCP-UDP-OSI参考模型/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/TCP-UDP-OSI参考模型/","excerpt":"","text":"TCP UDP基本区别1、TCP基于连接 UDP基于无连接2、TCP要求系统资源较多，UDP较少3、UDP程序结构较简单4、流模式（TCP）与数据报模式(UDP)5、TCP保证数据正确性，UDP可能丢包（TCP更可靠，UDP不可靠但是快） TCP 三次握手为了防止服务器端的一直等待而浪费资源第一次握手：客户端 SYN=1 用来建立连接 seq=x第二次握手：服务端 ACK=x+1 同意建立连接 seq=y SYN=1第三次握手：客户端收到了 ACK=y+1 Seq=x+1 1.第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;2.第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;3.第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 1.第一次分手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;2.第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;3.第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;4.第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 A—&gt;B Fin,B—&gt;A ACK, A属于主动关闭方，收到B的ACK后，A到B的方向连接关闭，即half shutown ，这时A不能再发送数据了。B—&gt;A Fin, 这种状态下B还是可以单向发送数据的A—&gt;B ACK B收到ACK，关闭连接如ACK没有到达B，B会为FIN这个消息超时重传 timeout retransmit那如果A等待时间足够，又收到FIN消息，说明ACK没有到达B，于是再发送ACK，直到在足够的时间内没有收到FIN，说明ACK成功到达。这个等待时间至少是：B的timeout + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。 OSI参考模型从底层到高层1、物理层 2、数据链路层 3、网络层 4、传输层 5、会话层 6、表示层 7、应用层 网络层： IP,ICMP,IGMP，【ARP,RARP】传输层：TCP,UDP,UGP应用层：Telnet,FTP,SMTP,SNMP, HTTP","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"Set和Map数据结构","slug":"Set和Map数据结构","date":"2018-04-27T08:44:00.000Z","updated":"2018-04-27T14:34:04.000Z","comments":true,"path":"2018/04/27/Set和Map数据结构/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Set和Map数据结构/","excerpt":"","text":"Set概念：类似于数组，成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成一个Set数据结构。123let s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x))for (i of s) &#123; console.log(i); &#125; // 2 3 5 4 表明Set结构不会添加重复的值。Set函数也可以接收一个数组作为参数，用于初始化特殊情况：12345let set = new Set();set.add(&#123;&#125;);set.size //1set.add(&#123;&#125;);set.size //2 NaN不等于自身，set内部的判断相等类似于精确相等（===） Set结构的实例属性Set.prototype.constructor：构造函数，默认就是set函数Set.prototype.size：返回Set实例的成员总数 Set实例的方法add(value)：添加某个值，返回Set结构本身delete(value)：删除某个值，返回一个布尔值，表示是否成功has(value)：判断是否是Set的成员，返回布尔值clear()：清除所有成员，无返回 与Array.from将Set结构转化为数组1234function dedupe(array)&#123; return Array.from(new Set(array));&#125;dedupe([1, 2, 3, 3]) //[1, 2, 3] 四种遍历操作 keys()：返回键名的遍历器values()：返回一个键值的遍历器entries()：返回一个键值对的遍历器forEach()：使用回调函数遍历每个成员 12345678910111213let set = new Set(['red', 'green', 'blue']);for(let item of set.keys())&#123; console.log(item);&#125;//red green bluefor(let item of set.values())&#123; console.log(item);&#125;//red green bluefor(let item of set.entries())&#123; console.log(item);&#125;//[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"] 也可以用for…of遍历123for(let x of set)&#123; console.log(x)&#125;//red green blue 由于扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构12let arr = [...set];//[\"red\", \"green\", \"blue\"] 另一种数组去重的方法12let arr = [1, 1, 2, 3];let unique = [...new Set(arr)];//[1, 2, 3] 扩展运算符：将数组转换成用逗号分隔的参数序列1Math.max(...[14, 3, 77]) Set结构的forEach方法用于对每个成员执行某种操作，没有返回值123let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value*2))//2 4 6 forEach方法本身的参数就是一个处理函数，处理函数参数依次是键值、键名、集合本身，forEach方法还可以有第二个参数，表示绑定的this对象 WeakSet WeakSet结构与Set类似，也是不重复的值的集合。与Set有两个区别：1、WeakSet的成员只能是对象，而不能是其他类型的值2、WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet中。这个特点意味着无法引用WeakSet的成员，因此WeakSet是不可遍历的 MapMap结构的目的和基本用法：JS的对象本质上是键值对的集合（Hash结构），但是只能用字符串作为键。这给它的使用带来了很大的限制。比如[Object Object]Map数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值(包括对象)都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更为完善的Hash结构实现。1、作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组 2、Map构造函数接受数组作为参数，实际上执行的是把key和value通过forEach，set进Map结构中 3、如果对同一个键多次赋值，后面的值将覆盖前面的值 4、如果读取一个未知的键，则返回undefined 5、只有对同一个对象的引用，Map结构才将其视为同一个键 6、Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键（解决了同属性名碰撞问题，扩展别人库时，使用对象作为键名就不用担心同名问题） 7、如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只需要两个值严格相等，Map就将其视为一个键，包括0和-0。且NaN虽然不严格等于自身，但Map将其视为同一个键 相关代码：12345let map = new Map();map.set(['a'], 555);map.get(['a']); // undifined// 表面是针对同一个键，但实际上这是两个值，内存地址不一样 Map的属性方法1、size属性：返回Mao结构的成员数量2、set方法：set（key，value）3、get方法：get（key）返回key4、has方法：has（key）键是否在Map中5、delete方法：delete（key）删除键返回布尔6、clear方法：clear（）清除所有成员7、keys（）、values（）、entries（）、forEach（）遍历方法 Map转化为其他数据结构 1、数组Map=&gt;数组：…扩展运算符[…map]数组=&gt;Map：数组直接传入Map 2、对象Map=&gt;对象：Map所有键都是字符串12345&gt;let obj = Object.creat(null);&gt;for(let [k, v] of xxx])&#123;&gt; obj[k] = v;&gt;&#125;&gt; 对象=&gt;Map：1234&gt;for(let k of Object.key(obj))&#123;&gt; map.set(k, obj[k]);&gt;&#125;&gt; 3、JSONMap=&gt;JSON12345&gt;fucntion strMapToJSON(strMap)&#123;&gt; return JSON.stringify([strMapToJSON(strMap)]);//键名是字符串&gt; return JSON.stringify([...map]);//键名非字符串&gt;&#125;&gt; JSON=&gt;Map1234&gt;function jsonToStrMap(jsonstr)&#123;&gt; return objToStrMap(JSON.parse(jsonstr));&gt;&#125;&gt; WeakMap与Map类似，区别：只接受对象作为键名（null除外），而且键名所指向的对象不计入垃圾回收机制","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"setTimeout和setInterval","slug":"setTimeout和setInterval","date":"2018-04-27T08:44:00.000Z","updated":"2018-04-29T09:25:38.000Z","comments":true,"path":"2018/04/27/setTimeout和setInterval/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/setTimeout和setInterval/","excerpt":"","text":"js是单线程的！！！定时器只是让代码在未来某个时间执行，执行时机是不保证的，因为在页面的生命周期中，不同时间可能有其他代码在控制js进程。在页面下载完成后的代码运行、时间处理程序、Ajax回调函数都必须使用同样的线程执行 浏览器负责进行排序，指派某段代码在某个时间点运行的优先级 JS代码没有任何代码是立即执行的，但一旦进程空闲则尽快进行 定时器队列的工作方式是，当特定时间过去后将代码插入。但是给队列添加代码不意味着对它立即执行，只是尽快执行。设定一个时间，表示在这段时间后代码被加入到队列中。如果这个时间上队列没有任何其他东西，那么这段代码就会被执行。 setInterval创建的定时器代码可能在再次被添加时，之前的代码队列还没执行完，结果导致定时器代码连续运行好几次，而之间没有停顿对于这种情况，当使用setInterval定时器时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。 问题：1、某些间隔会被跳过 2、多个定时器的代码执行之间的间隔可能会比预期的小比如定时器代码执行的时间超过了预定的时间间隔，冲突的定时器代码将不会被添加到队列中。也有可能添加进去后由于时间接近就马上执行了。 为了避免这个情况，使用链式的setTimeout好setTimeout(function(){ setTimeout(arguments.callee, time);}, time);arguments.callee 这个属性相当于一个指针，指向拥有这个arguments对象的函数 这样就可以在一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行完之前，至少要等待指定的间隔，避免了连续运行。 requestAnimationFramerequestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：1、requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，频率是每秒60帧2、在隐藏或不可见的元素中，requestAnimationFrame将不会重绘或者回流，减少渲染情况 window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 requestAnimationFrame会在JS执行栈结束后执行（也在Promise之后），再之后执行任务队列中放到JS执行栈中的任务 返回值：一个 long 整数，且非0，请求 ID ，是回调列表中唯一的标识。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Redux笔记","slug":"Redux笔记","date":"2018-04-27T08:37:00.000Z","updated":"2018-04-29T09:22:08.000Z","comments":true,"path":"2018/04/27/Redux笔记/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Redux笔记/","excerpt":"","text":"Redux 的设计思想很简单，就两句话。 （1）Web 应用是一个状态机，视图与状态是一一对应的。 （2）所有的状态，保存在一个对象里面。 基本概念和APIStoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过store.getState()拿到。1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。1store.dispatch(addTodo('Learn Redux')); ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;);","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"React笔记新","slug":"React笔记新","date":"2018-04-27T08:36:00.000Z","updated":"2018-04-29T09:32:56.000Z","comments":true,"path":"2018/04/27/React笔记新/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/React笔记新/","excerpt":"","text":"生命周期React组件可以经历三个阶段1、挂载阶段2、更新阶段3、卸载阶段 （1）挂载：这个阶段发生在组件被插入DOM时（2）更新：这个阶段发生在组件被重新渲染成虚拟DOM并决定实际DOM是否需要更新（3）卸载：这个阶段发生在组件从DOM中被删除时 挂载时1、getInitalState()2、componentWillMount()3、render()4、componentDidMount() getInitalState第一个被调用的。它会在React将组件插入DOM之前被调用。如果想让组件有一个state，可以使用这个方法返回初始的组件state。 componentWillMount第二个被调用的。它会在React将组件即将插入DOM时被调用。调用this.setState()方法会触发组件的render()方法，但这时调用React知道还没有开始渲染，所以仅仅调用render一次 render这时候第一次render compomentDidMount第三个被调用的。它会在React将组件插入到DOM之后立即被调用。更新后的DOM现在可以被访问可以在这里整合jQuery，Ajax请求，setTimeout定时器 卸载时componentWillUnmount这个阶段React仅提供这一个方法在React即将从DOM中删除并销毁组件之前被调用。用于清理组件在安装或更新阶段创建的所有数据。 更新时这时候React组件已经被插入到了DOM中。这个DOM代表组件的当前状态，并且当状态改变，React需要评估一个新的状态如何改变先前渲染的DOM 生命周期更新阶段的方法5个 按顺序执行1、componentWillReceiveProps()2、shouldComponentUpdate()3、componentWillUpdate()4、render()5、componentDidUpdate() componentWillReceiveProps更新阶段第一个被调用，就是当组件从父组件接收到新属性时被调用在这个阶段调用多次this.setState多少次，都不会触发组件额外的渲染。React会优化下，把状态更新操作放在一起批量执行最好在这个阶段操作state shouldComponentUpdate第二个被调用通过shouldComponentUpdate方法，可以决定组件的下一个状态是否触发组件的重新渲染。这个方法返回一个布尔值一般为true，但是如果为false，之后的componentWillUpdate、render、componentDidUpdate就不会被调用了如果跳过了render，就会阻止对该组件的重新渲染，这将提高应用程序的性能，因为DOM没有额外的改变 componentWillUpdate在React即将更新DOM之前被调用，有两个参数，nextProps：下一个属性对象 nextState：下一个状态对象不能在componentWillUpdate中使用this.setState componentDidUpdate在React更新DOM之后会被立即调用。有以下两个参数prevProps：上一个属性对象prevState：上一个状态对象使用这个方法来操作更新后的DOM或者执行渲染后的操作。 componentDidUpdate被调用之后，更新阶段结束。当组件的状态更新或者父组件传来一个新属性时，一个新的阶段又开始了 diffReact 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 diff策略1、web UI中DOM节点跨层级的移动操作特别少，可以忽略不计2、拥有相同同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构3、对于同一层级的一组子节点，它们可以通过唯一id进行区分基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。 tree diffReact对树的算法进行了简介明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：create A -&gt; create B -&gt; create C -&gt; delete A。![][1] component diffReact是基于组件构建应用，对于组件间的比较采取的策略也是简洁高效1、如果是同一类型的组件，按照原策略继续比较虚拟DOM树2、如果不是，则该组件判断为dirty component3、对于同一类型的组件，有可能其虚拟DOM没有变化，如果能够确切的知道这点可以节省大量的diff运行时间，因此React允许用户通过shouldComponentUpdate来判断组件是否需要diff![][2] 当D组件改为G组件时，即使这两个组件结构相似，一旦React判断D和G是不同类型的组件，就不会比较二者的结构，而是直接删除D组件，重新创建G组件以及其子节点。虽然两个组件是不同类型但结构相似。React diff会影响性能，但正如React官方博客所言：不同类型的组件是很少存在相似DOM树的机会，因此这种极端因素在开发中很难造成重大影响 element diff当节点处于同一层级时，Reactdiff提供了三种节点操作：插入、移动、删除插入：新的组件类型不在之前的集合里，即是全新的结点，需要对新的结点执行插入操作移动：在老集合有新组件类型，且结点是可更新的类型，就可以移动操作，可以复用以前的DOM结点删除：老的组件类型，新的集合里也有，但对应的结点不同则不能直接复用和更新，需要执行删除操作，或者老的组件不在新集合里的，也需要执行删除操作 组件通信![][3]几种通信情况1、父组件向子组件通信2、子组件向父组件通信3、跨级组件通信4、没有嵌套关系组件之间的通信 父组件向子组件通信父组件通过props向子组件传递需要的信息 子组件向父组件通信1、利用回调函数2、利用自定义事件机制 回调函数：在子组件中使用this.props.函数名 这个函数定义在父组件中，然后执行相应的操作，如配合setState 跨级组件通信1、层层组件传递props如A、B组件通信，先找到A和B的公共父组件，Ａ先向父组件通信，然后父组件通过props和B组件通信，此时父组件起的就是中间件的作用 2、使用contextcontext是一个全局变量，像是一个大容器，在任何地方都可以访问到，我们可以把要通信的信息放在context上，然后再其他组件中可以随意取到但是React官方不建议大量使用context，尽管他可以减少逐层传递，但是当组件结构复杂的时候，我们并不知道context是从哪里传过来的；而且context是一个全局变量，全局变量会导致应用混乱 没有嵌套关系的组件通信使用自定义事件机制在componentDidMount事件中，如果组件挂载完成，再订阅事件；在组件卸载的时候，在componentWillUnmount事件中取消事件订阅 总结 父组件向子组件通信: props 子组件向父组件通信: 回调函数/自定义事件 跨级组件通信: 层层组件传递props/context 没有嵌套关系组件之间的通信: 自定义事件 MixinReact的主流构建组件的方法是利用createClass创建，就是创造一个包含React方法Class类。这种实现，官方提供了非常有用的mixin属性。mixins接受一个数组 Mixin 就是用来定义一些方法，使用这个 mixin 的组件能够自由的使用这些方法（就像在组件中定义的一样），所以 mixin 相当于组件的一个扩展，在 mixin 中也能定义“生命周期”方法。 虽然组件的原则就是模块化，彼此之间相互独立，但是有时候不同的组件之间可能会共用一些功能，共享一部分代码。所以 React 提供了 mixins 这种方式来处理这种问题。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Promise对象","slug":"Promise对象","date":"2018-04-27T08:35:00.000Z","updated":"2018-04-27T08:35:44.000Z","comments":true,"path":"2018/04/27/Promise对象/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Promise对象/","excerpt":"","text":"Promise的含义所谓Promise，就是一个对象，用来传递异步传递消息的操作。Promise有两种特点：1、对象的状态不受外界影响。Promise对象代表一个异步操作。有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，人恶化其他操作都无法改变这个状态。2、一旦状态改变就不再改变。Promise对象的状态改变只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要其中之一发生，状态就会凝固，不再改变。再添加回调函数，也会立即得到这个结果。与事件不同，事件如果错过，再去监听也得不到结果。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调。Promise对象提供统一接口，使得控制异步操作更加容易。 Promise的缺点：1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。2、如果不设置回调函数，Promise内部抛出的错误不会反应到外部。3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。Pending时有可能是刚newPromise对象，也可能是等待回调操作 在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用.catch方法。 如果某些时间不断的反复发生，一般来说，使用stream模式是比部署Promise更好的选择。 Promise基本用法ES6规定，Promise对象是一个构造函数，用来生成Promise实例12345678var promise = new Promise(function(resolve, reject)&#123; // some code if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;); promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve：resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject：reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。如果紧跟的then没有声明onRejected回调，则传给下一个then|catch的onRejected，一直都没有，会报Uncaught错误如果resolve的参数是Promise对象，且该Promise对象后面没有跟then，则该对象的resolve|reject会触发外层Promise对象后续的then的onFulfilled|onRejected 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done');//第三个参数是前面函数要传入的参数 &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); // done 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 异步加载图片的例子123456789101112131415function loadImageAsync(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const image = new Image(); image.onload = () =&gt; &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。123456789101112131415161718192021222324252627const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。123456789var p1 = new Promise(function(resolve, reject)&#123; setTimeout(() =&gt; reject(new Error('fail')), 3000);&#125;);var p2 = new Promise(function(resolve, reject)&#123; setTimeout(() =&gt; resolve(p1), 1000);&#125;);p2.then(result =&gt; console.log(result));p2.catch(error =&gt; console.log(error));//Error: fail 上面的代码中，p1是一个Promise，3秒之后变为Rejected。p2的状态由p1决定，1秒之后，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不改变。又过了2秒，p1变为Rejected，p2也跟着变为Rejected。 Promise.prototype.then()Promise实例具有then方法。也就是说，then方法是定义在原型对象Promise.prototype上的。他的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例（不是原来那个）。因此可以采用链式写法，即then方法后面再调用另一个then方法12345getJSON(\"/post.json\").then(function(json)&#123; return json.post;&#125;).then(function(post)&#123; // ...&#125;); 上面的代码使用then方法依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数传入第二个回调函数。采用链式的then可以指定一组按照次序调用的回调函数。这时，前一个回调函数有可能返回的还是一个Promise对象（即有异步操作），而后一个回调函数就会等待该Promise对象的状态发生变化，在被调用。1234567getJSON(\"/post/1.json\").then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments)&#123; console.log(\"Resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"Rejected: \", err);&#125;); 上面的代码中，第一个then方法指定的回调函数返回的是另一个Promise对象。这时，第二个then方法指定的回调函数就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA；如果状态变为Rejected，就调用funcB。 用箭头函数写上面的代码123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL);).then( comments =&gt; console.log(\"Resolved: \", comments); err =&gt; console.log(\"Rejected: \", err);) Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 1、如果Promise状态已经变成Resolved，再抛出错误是无效的。12345678var promise = new Promise(function(resolve, rejected)&#123; resolve(\"ok\"); throw new Error(\"test\");&#125;);promise .then(function(value) &#123;console.log(value)&#125; ) .catch(function(error) &#123;console.log(error)&#125; )// ok 由于Promise在resolve语句后再抛出错误，并不会被捕获，等于没抛出 2、Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获位置。错误总会被下一个的catch语句捕获1234567getJSON(\"/post/1.json\").then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function(comments)&#123; // some code&#125;).catch(function(error)&#123; // 处理前面三个Promise产生的错误&#125;) 代码中一共有三个Promise对象：一个由getJSON产生，两个由then产生。其中任何一个抛出的错误都会被最后一个catch捕获 3、不要在then方法里定义Rejected状态的回调函数（即then产生的第二个参数），而应该总是使用catch12345678910111213promise .then(function(data)&#123; // success &#125;, function(err)&#123; // error &#125;);promise .then(function(data)&#123; // suceess &#125;) .catch(function(err)&#123; // error &#125;); 第二种方法更好，因为前者更接近同步的写法（try/catch） 4、跟传统的try/catch不同的是，如果没哟使用catch方法指定错误处理的回调函数Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。12345678var someAsyncThing = function()&#123; return new Promise(function(resolve, reject)&#123; resolve(x + 2); // x没有声明 &#125;);&#125;;someAsyncThing().then(function()&#123; console.log('everything is great');&#125;); someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，因而这个错误不会被捕获，也不会传递到外层代码，导致运行后没有结果1234567var promise = new Promise(function(resolve, reject)&#123; resolve(\"ok\"); setTimeout(function() &#123; throw new Error('test') &#125;, 0);&#125;);promise.then(function(value)&#123;console.log(value)&#125;);// ok// Uncaught Error: test 上面的代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try…catch语句，就冒泡到最外层，成了未捕获的错误。因此此时Promise的函数体已经运行结束，所以这个错误是在Promise外抛出的。Node.js有一个专门监听未捕获的Rejected错误。 5、catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。1234567891011121314var someAsyncThing = function()&#123; return new Promise(function(resolve, reject)&#123; resolve(x + 2); // x未声明 &#125;)；&#125;；someAsyncThing() .catch(function(error)&#123; console.log(error) &#125;) .then(function()&#123; console.log(\"carry no\") &#125;);// [ReferenceError: x is not defined]// carry on 代码中运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数 6、如果没有报错，就会跳过catch方法123456789Promise .resolve() .catch(function(error)&#123; console.log(error); &#125;) .then(function()&#123; console.log('carry on'); &#125;); //carry on 代码因为没有报错而跳过了catch方法，直接执行了后面的then方法。此时要是then方法里报错，就与前面的catch无关了 7、catch方法中还能再抛出错误1234567891011121314151617const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为 y 没有声明 y + 2;&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined] 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。1234567891011someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log('carry on', error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined] 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.all()Promise.all方法用于将多个Promise实例包装成一个新的Promise实例1var p = Promise.all([p1, p2, p3]); 代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例；如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理。Promise.all方法的参数不一定是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise实例p的状态由p1、p2、p3决定，分为两种情况 （1）只有p1、p2、p3的状态都变为Fulfilled，p的状态才会变为Fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数（2）只要p1、p2、p3中有一个被Rejected，p的状态就变成Rejected，此时第一个被Rejected的实例的返回值会传递给p的回调函数12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 12345678910111213const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race()Promise.race方法同样是将多个Promise实例包装成一个新的Promise实例1var p = Promise.race([p1, p2, p3]) 上面代码中，只要p1、p2、p3中有一个实例率先改变状态，p的状态就跟着改变。哪个率先改变的Promise实例的返回值，就传递给p的回调函数。 Promise.race方法的参数和Promise.all方法一样，如果不是Promise实例，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理 如果指定时间内没有获得结果，就将Promise的状态变为Rejected，否则变为Resolved12345678var p = Promise.race([ fetch('/that-a-while'), new Promise(function(resolve, reject)&#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)])p.then(respones =&gt; console.log(response))p.catch(error =&gt; console.log(error)) 上面的代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为Rejected，从而触发catch方法指定的回调函数 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 代码将jQuery生成的deferred对象转为新的Promise对象Promise.resolve等价于下面的写法123Promise.resolve(\"foo\")// 等价于new Promise(resolve =&gt; resolve('foo')) 如果Promise.resolve方法的参数不是具有then方法的对象，则返回一个新的Promise对象，且其状态为Resolved。12345var p = Promise.resolve('Hello');p.then(function(s)&#123; console.log(s)&#125;);// hello 上面的代码生成了一个新的Promise对象的实例p。由于字符串“hello”不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数就会立即执行。Promise.resolve方法的参数会同时传给回调函数。Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。1234var p = Promise.resolve();p.then(function()&#123; // ...&#125;) 上面的变量p就是一个Promise对象如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。 Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，状态为Rejected。Promise.reject方法的参数reason会被传递给实例的回调函数。1234567var p = Promise.reject('err');//等同于var p = new Promise((resolve, reject) =&gt; reject('foo'))p.then(null, function(s)&#123; console.log(s)&#125;);//err 代码生成一个Promise对象的实例p，状态为Rejected，回调函数会立即执行。 附加done和finallydone()Promise对象的回调链，不管以then方法还是catch方法结尾，要是最后一个方法抛出错误都有可能无法捕捉到（因为Promise内部错误不会冒泡到全局）。done方法放在回调链的尾端，保证抛出任何可能出现的错误12345asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); 实现代码：1234567Promise.prototype.done = function(onFulfilled, onRejected)&#123; this.then(onFulfilled, onRejected) .catch(function(reason)&#123; // 抛出全局错误 setTomeout(() =&gt; &#123; throw reason &#125;, 0); &#125;)&#125; done方法可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done方法都会捕捉到任何可能出现的错误，并向全局抛出。 finally()finally方法用于指定不管Promise对象最后状态如何都会执行的操作。它与done方法的最大区别在于，它接受一个普通的回调函数作为参数，然后使用finally方法关掉服务器。下例，服务器使用Promise处理请求，然后使用finally方法关掉服务器。12345server.listen(0) .then(function()&#123; // run test &#125;) .finally(server.stop) finally实现1234567Promise.prototype.finally = function(callback)&#123; let p = this.constructor; return this.then( value =&gt; p.resolve(callback().then(() =&gt; value)) reason =&gt; p.resolve(callback().then(() =&gt; &#123; throw reason &#125;)) );&#125; 上面的代码中，不管前面的Promise是Fulfilled还是Rejected，都会执行回调函数callback。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"new时候发生了什么","slug":"new时候发生了什么","date":"2018-04-27T08:34:00.000Z","updated":"2018-04-27T08:35:08.000Z","comments":true,"path":"2018/04/27/new时候发生了什么/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/new时候发生了什么/","excerpt":"","text":"123456789function Animate(name)&#123; this.name = name;&#125;Animate.prototype.dance = function()&#123; console.log(this.name + \"在跳舞\");&#125;var dog = new Animate('旺财');dog.dance(); new Animate(‘旺财’)时候：1、创建了一个新的对象 var obj = {}2、将Animate中的this关键字指向obj3、将Animate的prototype原型指向obj原型，这样obj就拥有了Animate中的方法4、执行Animate构造函数的代码（this.name=name） 123456var obj = &#123; name: \"旺财\", dance: function()&#123; console.log(this.name + \"在跳舞\"); &#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"let const var","slug":"let-const-var","date":"2018-04-27T08:34:00.000Z","updated":"2018-04-27T08:34:38.000Z","comments":true,"path":"2018/04/27/let-const-var/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/let-const-var/","excerpt":"","text":"let const varvar声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 const声明的如果有栈内存在的值和地址则不能修改1、如果是值类型，值不可变2、如果是引用类型，地址不可变基本类型boolen,number,string直接值存在栈内引用类型Object(function,array)值存在对应的地址中，const声明的不能重新改变地址 1234var a = 2var obj = &#123; prop: 5&#125; 整个内存的分配你可以这么假想1、对于a, 就是栈上存一个a变量， a存储的值为22、对于obj，可以拆分成两部分， 一部分是堆中（也就是{prop: 5}）这一部分， 另一部分在栈中（obj这一部分）。3、这里我们不分析堆中的，只管栈这一部分，那么obj可以看成是一个存储这地址的“简单数据类型”（因为一个地址占的字节数和简单数据类型差不多），obj的值为0x10000000这样4、假设执行obj.prop = 6, 实际上是改变了{prop: 5}这一部分， 而obj的值并没有改变。依然是0x10000000, 数组的原理与之类似5、当你执行obj = {key: ‘foo’}, 是在堆中开辟了一个新的对象，然后把地址赋给了obj， 那obj的值肯定就变了， 那以前{prop: 5}这一部分去哪里了呢？ 被垃圾回收给清除了","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"JS变量、函数提升","slug":"JS变量、函数提升","date":"2018-04-27T08:32:00.000Z","updated":"2018-04-29T09:36:28.000Z","comments":true,"path":"2018/04/27/JS变量、函数提升/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/JS变量、函数提升/","excerpt":"","text":"变量提升在ES6前，JS没有块级作用域，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。 123console.log(global); // undefinedvar global = 'global';console.log(global); // global 会先把声明提前，在对应的位置再赋值 函数提升函数创建的方式有两种：函数声明和函数字面量。只有函数声明才存在函数提升！ 1234console.log(f1); // function f1() &#123;&#125;console.log(f2); // undefinedfunction f1() &#123;&#125;var f2 = function() &#123;&#125; 执行结果是因为函数声明会被直接提到作用域开始地方。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"JS函数参数值传递和引用传递 ","slug":"JS函数参数值传递和引用传递","date":"2018-04-27T08:32:00.000Z","updated":"2018-04-29T14:33:56.000Z","comments":true,"path":"2018/04/27/JS函数参数值传递和引用传递/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/JS函数参数值传递和引用传递/","excerpt":"","text":"概念按值传递：最常用的求值策略，函数的形参是被调用时所传实参的副本。修改形参的值并不影响形参。按引用传递：实际上是对实参引用变量的复制，导致实参、形参都指向同一个对象实体。形参的改变会同时改变实参的值。形参：在定义函数名和函数体时候使用的参数，目的是用来接收调用该函数时传递的参数。实参：在调用时传递给函数的参数。 按值传递123456789function add(num)&#123; num++; return num;&#125;var count = 0;var result = add(count); // 按值传递 num=countconsole.log(count); // 还是0console.log(result); // 变为1 传递完后两个变量各不相干 按引用传递123456function setName(obj)&#123; obj.name = \"joe\";&#125;var person = new Object();setName(person);console.log(person.name) // joe 当var person = new Object();时当函数setName(person);时，下图可以表示全局变量person和局部变量obj的关系以上代码中创建一个对象，并将其保存在变量person中。然后，这个变量被传递到setName(obj)函数中之后就复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使ECMAScript说这个变量是按值传递的，但obj也会按引用来访问同一个对象。于是，在函数内部为obj添加name属性后，函数外部的person也将有所反应；因为这时的person和obj指向同一个堆内存地址。所以，很多人错误的认为：在局部作用域中修改的对象会在全局对象中反映出来，就说明参数是按引用传递的。 12345678function setName(obj)&#123; obj.name = 'joe'; obj = new Object(); // 改变obj的指向，此时obj指向一个新的内存地址，不再和person指向同一个 obj.name = 'wyj';&#125;var person = new Object();setName(person);console.log(person.name); // joe 当创建obj对象obj = new Object();时这个例子与前一个唯一的区别，就是setName()函数中添加了两行代码：obj = new Object();用来改变obj的指向。obj.name = ‘wyj’; 用来给新创建的obj添加属性。如果是按引用传递的，那么person就会自动被修改为指向新创建的obj的内存地址，则person的name属性值被修改为wyj。但是，当访问person.name时，显示的结果为joe。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完后被立即销毁。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Iterator和for...of循环","slug":"Iterator和for-of循环","date":"2018-04-27T08:31:00.000Z","updated":"2018-04-27T08:31:48.000Z","comments":true,"path":"2018/04/27/Iterator和for-of循环/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Iterator和for-of循环/","excerpt":"","text":"Iterator 遍历器遍历器（Iterator）为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署Iterator接口，就可以完成遍历操作。 Iterator作用：1、为各种数据结构提供一个统一的、简便的访问接口2、使数据结构的成员能够按某种次序排列3、ES6创造了一种新的遍历命令——for…of循环，Iterator接口主要共for…of消费 Ierator遍历过程：1、创建一个指针对象，指向当前数据结构的起始位置。遍历器对象本质上就是一个指针对象 2、第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员 3、第二次调用指针对象的next方法，指针就指向数据结构的第二个成员 4、不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束 1234567891011121314let it = makeIterator(['a', 'b']);it.next(); //value:a,done:falseit.next(); //value:b,done:falseit.next(); //value:undefined,done:truefunction makeIterator(array)&#123; var nextIndex = 0; return &#123; next: function()&#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125; &#125; &#125;&#125; 函数返回一个遍历器对象（即指针对象） ES6中有些数据结构具备原生的Iterator接口（比如数组），不用任何处理就可以被for..of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性。凡部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用接口就会返回遍历器对象。ES6中，数组、Set、Map具有原生数据结构Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放到方括号中。1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() //&#123;value: 'a', done: false&#125;;iter.next() //&#123;value: 'b', done: false&#125;;iter.next() //&#123;value: 'c', done: false&#125;;iter.next() //&#123;value: undefined, done: true&#125;; 调用Iterator接口的场合有一些场合会默认调用Iterator接口(即Symbol.iterator方法) 1、解构赋值对数组和Set解雇进行解构赋值时，会默认调用Symbol.iterator方法123let set = new Set().add('a').add('b').add('c');let [x, y] = set; //x='a' y='b'let [first, ...rest] = set; //first='a' second=['b', 'c'] 2、扩展运算符扩展运算符(…)也会调用默认的Iterator接口12345var str = \"hello\";[...str] //['h', 'e', 'l', 'l', 'o']let arr = ['b', 'c'];['a', ...arr, 'd'] //['a', 'b', 'c', 'd'] 上面的扩展运算符内部就调用了Iterator接口实际上，这提供了一种机制，可以将任何部署了Iterator接口的数据结构转化为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。1let arr = [...iterable]; 3、yield*yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口1234567891011121314let generator = function* () &#123; yield 1; yield* [2, 3, 4]; yield 5;&#125;;var iterator = generator();iterator.next(); //&#123; value: 1, done: false &#125;iterator.next(); //&#123; value: 2, done: false &#125;iterator.next(); //&#123; value: 3, done: false &#125;iterator.next(); //&#123; value: 4, done: false &#125;iterator.next(); //&#123; value: 5, done: false &#125;iterator.next(); //&#123; value: 6, done: false &#125;iterator.next(); //&#123; value: undefined, done: true &#125; 4、其他场合由于数组的遍历会调用遍历器接口，所以任何接受任何数组作为参数的场合其实都调用了遍历器接口。 for…of Array.from() Map()、Set()、WeakMap()和WeakSet()（比如new Map([[‘a’, 1], [‘b’, 2]])） Promise.all() Promise.race() for…of一个数据结构只要部署了Symbol.iterator属性，就被视为具有Iterator接口，就可以用for…of循环遍历它的成员。 1、数组数组原生具备Iterator接口，for…of循环本质上就算是调用这个接口产生的遍历器 123456789&gt;const arr = ['red', 'green', 'blue'];&gt;let iterator = arr[Symbol.iterator]();&gt;for(let v of arr)&#123;&gt; console.log(v); // red green blue&gt;&#125;&gt;for(let v of iterator)&#123;&gt; console.log(v); // red green blue&gt;&#125;&gt; 以上两种方法等价JS原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值1234567var arr = ['a', 'b', 'c', 'd'];for(let a in arr)&#123; console.log(a); //0 1 2 3 键名&#125;for(let a of arr)&#123; console.log(a); //a b c d 键值&#125; 2、Set和Map结构Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环（1）遍历的顺序是按照各个成员被添加进数据结构的顺序（2）Set结构遍历时返回的是一个值，而Map结构遍历时返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。 3、计算生成的数据结构有些数据结构是现有数据结构基础上计算生成的，比如以下3个方法调用后 entries()返回遍历器对象，用于遍历【键名， 键值】组成的数组 keys()返回一个遍历器对象，用于遍历所有的键名 values()返回一个遍历器对象，用于遍历所有的键值 4、类似数组的对象比如字符串、DOM NodeList对象、arguments对象但并不是所有类似数组的对象都具有Iterator接口。一个简便的方法是使用Array.from方法将其转化为数组1234567let arrayLike = &#123;length: 2, 0: 'a', 1: 'b'&#125;;for(let x of arrayLike)&#123; console.log(x);&#125; // 报错for(let x of Array.from(arrayLike))&#123; console.log(x);&#125; 5、对象对于普通的对象，for…of结构不能直接使用，会报错，必须部署了接口才能使用。但是，这样的情况下，for…in循环依然可以用于遍历键名。12345678910111213var es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\"&#125;;for(e in es6)&#123; console.log(e);&#125;// edition ommittee standardfor(e of es6)&#123; console.log(e);&#125;// error es6 is not iterable 解决办法：1、使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组123for(var key of Object.keys(someObj))&#123; console.log(key + \":\" + someObj[key])&#125; 2、在对象上部署Iterator接口的代码，可以直接赋值给其他对象的Symbol.iterator属性12// 让for...of循环遍历jQuery对象jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator] 3、使用Generator函数将对象重新包装12345678function* entries(obj)&#123; for(let key of Object.keys(obj))&#123; yield [key, obj[key]]; &#125;&#125;for(let [key, value] of entries(obj))&#123; console.log(key, \"-&gt;\", value);&#125;// a-&gt;1 b-&gt;2 c-&gt;3 for…in的缺点1、数组的键名是数字，但是for…in循环是以字符串作为键名，“0”、“1”、“2”2、for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键3、某些情况下 ，for…in循环主要是遍历对象而设计的，不适合遍历数组 for…of的优点1、有着同for…in一样的简介语法，但是没有for…in那些缺点2、不同于forEach方法，它可以与break、continue、和return配合使用3、提供了遍历所有数据结构的统一操作接口","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"HTTP （输入URL发生啥）","slug":"HTTP-（输入URL发生啥）","date":"2018-04-27T08:30:00.000Z","updated":"2018-04-27T08:31:20.000Z","comments":true,"path":"2018/04/27/HTTP-（输入URL发生啥）/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/HTTP-（输入URL发生啥）/","excerpt":"","text":"http请求报文由3部分组成：请求行、请求头、请求体请求行请求方法 请求URL HTTP协议及版本 请求头1、Accept：请求报文可通过一个“Accept”报文头属性告诉服务端 客户端接受什么类型的响应。 2、Cookie：客户端的cookie通过这个报文头属性传给服务端。通过cookie中的sessionid与session服务关联起来。 3、Referer：表示这个请求是从哪个URL过来的。 4、Cache-Control：对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。 请求体请求的参数啥了 http响应报文由3部分组成：响应行、响应头、响应体请求行报文协议 状态码及描述 状态码：1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急…2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。 200 OK 成功304 Not Modified 请求的这个资源至你上次取得后，并没有更改，可以直接用本地的缓存404 Not Found 页面不存在500 Internal Server Error 服务器问题 响应头1、Cache-Control：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 2、ETag：一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。 3、Set-Cookie：服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的 输入URL到页面加载完发生了什么URL统一资源定位符，俗称网页地址URL中包括：1、传送协议protocol：最常用的是HTTP协议2、主机host：通常为域名或者IP地址3、端口号port：以数字形式表示4、路径path：以“/”字元区别路径中的每一个目录名称5、查询query：以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与其对应的值6、片段fragment：也就是在浏览器环境下location的hash值，用于指定网络资源中的片断，一般用于定位到某个位置 浏览器发生了什么：1、浏览器查询缓存2、浏览器询问操作系统服务器的IP地址3、操作系统做DNS查询，返回IP地址给浏览器4、浏览器与服务器建立TCP连接5、浏览器通过TCP连接发送HTTP请求6、浏览器接收HTTP响应7、浏览器检查响应，并解码，并根据类型处理 如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息 页面加载完成有两种事件一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）二是onload，指示页面包含图片等文件在内的所有元素都加载完成 HTTP数据 + TCP首部 + IP首部 + 以太网首部 应用层 传输层 网络层 链路层 IP协议IP协议的作用就是把各种数据包传送给对方。传输时需要满足条件是：IP地址和MAC地址IP地址指明了结点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP可变，MAC不可变 IP间通信依赖MAC地址。在网络上，通信的双方在同一局域网内的情况很少，通常需要中转设备，中转时，会利用下一站中转设备的MAC地址来搜索下一中转目标。这时，会采用ARP协议来解析地址，根据通信方的IP地址就可以反查出对应的MAC地址。（ARP协议：IP地址解析成对应的MAC地址） TCP协议TCP提供可靠字节流服务字节流服务：为了方便传输，将大块数据分割成报文段为单位的数据包进行管理可靠服务：能够把数据准确可靠地传给对方，能够确认数据最终是否送达到对方 为了准确送达，TCP采用了三次握手策略。用TCP协议把数据包送出去，TCP不会置之不理，会向对方确认是否成功送达。握手时采用了TCP的标志————SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息发送端再回传一个带ACK标志的数据包，代表握手结束 如果握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包 DNS服务DNS服务和HTTP协议都在应用层。它提供域名到IP地址之间的解析服务DNS作用：提供通过域名查找IP地址，或者逆向从IP地址反向查域名的服务 HTTP和各种协议的关系1、客户端向DNS发个域名，DNS服务返回对应的IP2、HTTP向目标服务器发送请求3、TCP的协议将HTTP请求报文分割成报文段，按序号分为多个报文段，把每个报文段可靠地传给对方4、IP协议搜索对方的地址，一边中转一边传送5、TCP协议收到了报文段，再按照序号以原来的顺序重组请求报文6、HTTP协议拿到内容 持久连接1、多个HTTP请求，需要建立多次TCP连接，开销太大2、出现了HTTP keep-alive的方法3、持久连接的特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态4、在HTTP1.1中，所有连接默认都是持久连接5、持久连接使多数请求可以管线化。不用等服务器响应就可以继续发请求 内容协商机制1、服务器驱动协商 由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据。并不一定能筛选出最优内容。 2、客户端驱动协商 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JS脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。 3、透明协商 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种办法 http1.0中的缓存控制： Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri,If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内http1.1中的缓存控制： Cache-Control：缓存控制头部，有no-cache、max-age等多种取值Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"Get和Post区别","slug":"Get和Post区别","date":"2018-04-27T07:49:00.000Z","updated":"2018-04-27T07:49:44.000Z","comments":true,"path":"2018/04/27/Get和Post区别/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Get和Post区别/","excerpt":"","text":"一些理解1、Get后退按钮/刷新无害，Post数据会被重新提交（浏览器应该告知用户数据会被重新提交）2、Get书签可收藏，Post为书签不可收藏3、Get能被缓存，Post不能缓存4、Get编码类型application/x-www-form-url，Post编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码5、Get历史参数保留在浏览器历史中，Post参数不会保存在浏览器历史中6、Get对数据长度有限制，当数据发送时，Get方法向URL添加数据，URL的长度是受限制的（URL的最大长度是2048个字符）,Post无限制7、Get只允许ASCⅡ字符，Post没有限制，也允许二进制数据8、Get不安全，发送的数据是URL的一部分。Post安全一点，因为参数不会被保存在浏览器历史或者Web服务器日志中。9、Get产生一个TCP数据包，Post产生2个TCP数据包 Get时，浏览器会把http header和data一并发送过去，服务器响应200， Post时，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据) jsonpjsonp只能get同源策略：域名、协议、端口12345678910 oBtn.onclick = function() &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert( xhr.responseText ); &#125; &#125;; xhr.open('get', 'https://api.douban.com/v2/book/search?q=javascript&amp;count=1', true); xhr.send(); &#125;; 但是img的src（获取图片），link的href（获取css），script的src（获取javascript）这三个都不符合同源策略，它们可以跨域获取数据。jsonp是动态创建script标签，然后利用script的src不受同源策略约束来跨域获取数据jsonp由两部分组成：回调函数和数据。回调函数是当相应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的json格式数据123var script = document.createElement(\"script\");script.src = \"xxoo?canshu=1&amp;result=ok&amp;callback=myCallbackName\";document.body.insertBefore(script, document.body.firstChild); 在页面中，返回的json作为参数传入回调函数123function myCallbackName(result)&#123; console.log(result);&#125; 传递一个callback参数给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。 例子在跨域服务器上xx.js:1localHandler(&#123;\"result\":\"远程js带来的数据\"&#125;) 本地：123456&lt;script&gt; var localHandler = function(data)&#123; alert(\"本地得到远程的数据是：\" + data.result); &#125;&lt;/script&gt;&lt;script src=\"跨域服务器/xxoo.js\"&gt;&lt;/script&gt; 本地定义一个函数，引入外部js，外部的js里调用这个函数但是服务器端不知道本地函数的名字 node后台可以动态获取函数名，然后返回12345678910var express = require('express');var router = express.Router();router.get('/xxoo', function(req, res, next)&#123; var _callback = req.query.callback; var _data = &#123;json&#125;; if(_callback)&#123; res.type('text/javascript'); //告诉浏览器这是js代码 res.send(_callback + \"()\") &#125;&#125;) 通过获取请求的url中callback=xx的拼接信息动态的获取到函数名称或者直接用res.jsnop(); jsonp缺点1、只能get2、失败不返回状态码3、需要保证请求地址的安全性","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"Generator函数","slug":"Generator函数","date":"2018-04-27T07:48:00.000Z","updated":"2018-04-27T07:49:16.000Z","comments":true,"path":"2018/04/27/Generator函数/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Generator函数/","excerpt":"","text":"简介 1、Generator函数是ES6提供的一种异步编程方案2、从语法上，首先可以把它理解成一个状态机，封装了多个内部状态3、Generator函数还是一个遍历器对象生成函数，返回遍历器对象4、Generator函数有两个特征：1、function命令与函数名之间有一个星号；2、函数体内部使用yield语句定义不同的内部状态（“yield”在英语里的意思是“产出”） 123456function* helloWorldGenerator()&#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 定义了一个Generator函数——helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello、world和return语句（结束执行）在调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象。下一步必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或从函数上一次停下来的地方开始执行，直到遇到下一条yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行1234hw.next() // &#123;value: 'hello', done: false &#125;hw.next() // &#123;value: 'world', done: false &#125;hw.next() // &#123;value: 'ending', done: true &#125;hw.next() // &#123;value: undefined, done: true &#125; ES6没有规定function关键字与函数名之间的星号必须在哪 yield语句由于Generator函数返回的遍历器对象只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。遍历器对象的next方法的运行逻辑如下： 1、遇到yield语句就暂停执行后面的操作，并将紧跟在yield后的表达式的值作为返回的对象的value属性值2、下一次调用next方法时才会继续执行，直到遇到下一个yield语句。3、如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值作为返回的对象的value属性值。4、如果该函数没有return语句，则返回的对象的value属性值为undefined。 要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JS提供了手动的“惰性求值”的语法功能。123function* gen()&#123; yield 123+456;&#125; 上面的代码中，yield后面的表达式123+456不会立即求值，只会在next方法将指针移到这一语句时才求值 Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。1234567function* f()&#123; console.log('执行了');&#125;var generator = f();setTimeout(function()&#123; generator.next();&#125;, 2000); 如果f只是普通函数，在为变量generator赋值时就会执行。但是函数f是一个Generator函数，于是就变成只有调用next方法时才会执行。要注意yield语句不能再普通函数中，yield语句在表达式中，必须放在括号里 next方法next方法可以携带一个参数：12345678910function* f()&#123; for(var i=0; true; i++)&#123; var reset = yield i; if(reset) &#123;i = -1&#125;; &#125;&#125;var g = f();g.next() // &#123;value: 0, done: false&#125;g.next() // &#123;value: 1, done: false&#125;g.next(true) // &#123;value: 0, done: false&#125; 定义了一个可以无限循环的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset就会被重置为这个参数，因而i会等于-1，下一轮循环就从-1开始递增。 Generator函数从暂停到恢复运行，其上下文状态是不变的。通过next方法的参数就有办法在Generator函数开始运行后继续向函数提内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。1234567891011121314function* foo(x)&#123; var y = 2 * (yield(x + 1)); var z = yield( y / 3 ); return (x + y + z);&#125;var a = foo(5);a.next()//Object&#123;value:6, done:false&#125;a.next()//Object&#123;value:NaN, done:false&#125;a.next()//Object&#123;value:NaN, done:false&#125;var b = foo(5);b.next()//Object&#123;value:6, done:false&#125;b.next(12)//Object&#123;value:8, done:false&#125;b.next(13)//Object&#123;value:42, done:false&#125; 如果next中没有参数，yield就返回undefined。所以在a第二次调next是y=2*undefined，所以结果为NaN。在实例b中，第一次yield返回6。第二次传入12，所以第二次返回的值为2*12再除以3，所以结果为8.第三次同理next参数就是上一条yield的返回值，所以第一次yield时不能带有参数。V8引擎会忽略第一次next时的参数，只从第二次使用next方法开始参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。如果想要第一次next带有参数，需要在Generator函数外再包一层。123456789101112function wrapper(generatorFunction)&#123; return function(...args)&#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log('First input: $&#123;yield&#125;'); return 'DONE';&#125;);wrapped().next('hello!'); 如果Generator函数不用wrapper先包一层，是无法第一次调用next方法就输入参数的。 for…offor…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。12345678910111213function *foo()&#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for(let v of foo()&#123; console.log(v);&#125;)//1 2 3 4 5 for…of遇到done属性为true就会终止，且不包含该返回对象。所以return的6就不包括在for…of中 Generator与协程协程是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程可以用单线程实现，也可以用多线程实现；前者是一种特殊的子线程，后者是一种特殊的线程。 协程与子例程的差异传统的“子例程”采用堆栈式“先进后出”的概念实现，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程可以并行执行，但只有一个线程处于正在运行状态，其他线程都处于暂停态，线程之间可以交换执行权。也就是说，一个线程执行到一半，可以暂停执行，将执行权交给另一个线程，等到稍后回收执行权时再恢复执行。这种可以并行执行，将执行权交给另一个线程，等到稍后收回执行权时再恢复执行。这种可以并行执行、交换执行权的线程，就成为协程。从实现上看，在内存中子例程只使用一个栈，而协程是同时存在多个栈，但只有一个栈是在运行态。也就是说，协程是以多占用内存为代价实现多任务的并行运行。 协程与普通线程的差异不难看出，协程适用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己执行的上下文，可以分享全局变量。他们不同之处在于，同一时间可以有多个线程是抢占式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误时可以找到原始的调用栈，不至于像异步操作的回调函数那样，一旦出错原始的调用栈早已结束。Generator函数是ES6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”，意思是只有Generator函数的调用者才能将程序的执行权还给Generator函数。如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。 1、异步操作的同步化表达Generator函数的暂停执行效果，意味着可以把异步操作卸载yield语句里面，等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用于处理异步操作，改写回调函数12345678910function* loadUI () &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();//加载UIloader.next();//卸载UIloader.next(); 上面的代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示加载界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏加载界面。可以看到，这种写法的好处是所有加载界面的逻辑都被封装在一个函数中，按部就班非常清晰。 Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。123456789101112function* main()&#123; var result = yield request(\"http://xxoo\"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url)&#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面的main函数就是通过AJAX操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法一模一样。注意，makeAjaxCall函数中的next方法必须加上response参数，因为yield语句构成的表达式本身是没有值的，总是等于undefined。 通过Generator实现的逐行读取文本文件。12345678910function* numbers()&#123; let file = new FileReader(\"numbers.txt\"); try&#123; while(!file.eof)&#123; yield parseInt(file.readLine(), 10); &#125; &#125;finally&#123; file.close(); &#125;&#125; 上面代码可以使用yield手动逐行读取文件 2、控制流管理如果有一个多步操作非常耗时，采用回调函数可能会写成这样。。123456789step1(function(value1)&#123; step2(value1, function(value2)&#123; step3(value2, function(value3)&#123; step4(value3, function(value4)&#123; // Do something with value4 &#125;) &#125;) &#125;)&#125;); 采用Promise改写上面的代码如下12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function(value4)&#123; //Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码把回调函数改成了直线执行的形式，但是加入了大量Promise的语法Generator函数可以进一步改善代码运行流程1234567891011function* longRunningTask()&#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step2(value2); var value4 = yield step2(value3); // do something with value4 &#125;catch(e)&#123; // handle any err &#125;&#125; 然后使用一个函数按次序自动执行所有步骤123456789101112scheduler(longRunningTask());function scheduler(task)&#123; setTimeout(function()&#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if(!taskObj.done)&#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125; yield语句是同步运行，不是异步运行（否则失去取代回调函数的设计目的）多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有当任务A和任务B都执行完时才能执行C），可以采用数组的写法。1234567function* parallelDownloads()&#123; let [ text1, text2 ] = yield [ taskA(); taskB(); ]; console.log(text1, text2);&#125; 上面的代码中，yield语句的参数是一个数组，成员就是两个任务——taskA和taskB，只有等这两个任务都完成，才会接着执行下面的语句 3、部署Iterator接口利用Generator函数可以在任意对象上部署Iterator接口。123456789101112function* iterEntries(obj)&#123; let keys = Object.keys(obj); for(let i=0; i&lt;keys.length; i++)&#123; let key = key[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123;foo: 3, bar: 7&#125;;for(let [key, value] of iterEntries(myObj))&#123; console.log(key, value);&#125;// foo 3 bar 7 代码中，myObj是一个普通对象，通过iterEntries函数就有了Iterator接口。也就是说，可以在任意对象上部署next方法。 4、作为数据结构Generator可以看作数据结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式提供类似数组的接口。12345function *doStuff()&#123; yield fs.readFile.bind(null, 'xx.txt'); yield fs.readFile.bind(null, 'oo.txt'); yield fs.readFile.bind(null, 'zz.txt');&#125; 上面代码一次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样处理这三个返回的函数123for(task of doStuff())&#123; //task是一个函数，可以像回调函数那样使用它&#125; Generator使得数据或者操作具备了类似数组的接口","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Express中间件","slug":"Express中间件","date":"2018-04-27T07:47:00.000Z","updated":"2018-10-13T07:32:52.575Z","comments":true,"path":"2018/04/27/Express中间件/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Express中间件/","excerpt":"","text":"Express是一个基于Node平台的web应用开发框架，在Node基础上扩展了web应用开发所需要的基础功能 Express处理各种请求是通过Express执行函数去调用对应的方法，这样是不是更加方便和快捷了。 中间件结构app.use(path, function)path：是路由的URL，意义是路由到这个路径时使用这个中间件function：中间件函数这个中间件函数可以理解为就是function(request,response,next) 中间件分类1、内置中间件express.static 是Express目前唯一内置的一个中间件。用来处理静态资源文件。app.use(express.static(__dirname + ‘/public’)); 2、自定义中间件在上面中间件结构中，中间件使用时第二个参数是一个function，这个回调有三个参数(req, res, next) 每个请求到达服务器时：（1）node会为请求创建一个请求对象(request)，该请求对象包含客户端提交上来的数据。（2）同时也会创建一个响应(response)，响应对象主要负责将服务器的数据响应到客户端。（3）最后一个参数next是一个方法，在应用中会用到多个中间件，想要运行下一个中间件，那么上一个中间件必须运行next() 3、第三方中间件body-parser ：解析body中的数据，并将其保存为Request对象的body属性cookie-parser ：解析客户端cookie中的数据，并将其保存为Request对象的cookie属性express-session ：解析服务端生成的sessionid对应的session数据，并将其保存为Request对象的session属性query：这个中间件将一个查询字符串从URL转换为JS对象，并将其保存为Request对象的query属性。这个中间件在第四个版本中已经内置了无需安装。 到底是什么浏览器向服务器发送一个请求后，服务器直接通过request定位属性的方式得到通过request携带过去的数据（有用户输入的数据和浏览器本身的数据信息）这中间就一定有一个函数将这些数据分类做了处理，处理好后，让request对象调用使用。这个处理数据的处理函数就是中间件，有以下几个特点1、封装了一些处理一个完整事件的功能函数2、非内置的中间件需要安装后，require到文件就可以运行3、封装了一些或许复杂但肯定是通用的功能","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"DNS查询过程","slug":"DNS查询过程","date":"2018-04-27T07:35:00.000Z","updated":"2018-04-27T07:35:40.000Z","comments":true,"path":"2018/04/27/DNS查询过程/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/DNS查询过程/","excerpt":"","text":"域名系统DNS服务就是把域名转换为IP地址。 查询步骤：1、在hosts静态文件、DNS解析器缓存中查找某主机的ip地址2、上一步无法查找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、缓存中查找3、本地DNS服务器查不到就查询上一层次的所有区域服务器，以此类推直至根域名DNS服务器4、到达根域名服务器后又向下查询，直至查到结果为止","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"cookies,session,webStorage,Manifest","slug":"cookies-session-webStorage-Manifest","date":"2018-04-27T07:33:01.000Z","updated":"2018-05-26T15:58:34.000Z","comments":true,"path":"2018/04/27/cookies-session-webStorage-Manifest/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/cookies-session-webStorage-Manifest/","excerpt":"","text":"cookiecookie的内容主要包括：名字、值、过期时间、路径、域。 路径和域一起构成cookie的作用范围，如不设置时间，则表示这个cookie的生命周期为浏览器会话期间，关闭浏览器窗口，cookie就会消失。这种生命周期为浏览器会话期的cookie被称为会话cookie。 会话cookie一般不存储在硬盘而是保存在内存里，若果设置了过期时间，浏览器会把cookie保存在硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期设置的过期时间。对于保存在内存里的cookie，不同浏览器有不同的处理方式session机制。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含一个session表示（称为sessionID），如果已包含则说明以前已经为客户端创建过session，服务器就会按照sessionID把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含sessionID，则为客户端创建一个session并且生成一个与此session相关联的sessionID，sessionID的值应该是一个既不会重复，又不容易找到规律以仿造的字符串，这个sessionID将被在本次响应中返回给客户端保存。保存这个sessionID的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个表示发给服务器。 关于session机制由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 cookie和session的区别 1、cookie数据存放在客户端浏览器，session数据放在服务器 2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session 3、session会在一定时间内保存在服务器上，当访问量增多，会比较占用你服务器性能，考虑到减轻服务器性能应当使用cookie 4、单个cookie保存的数据不能超过4k，肯多浏览器都限制一个站点最多保存20个cookie 5、建议将登录等重要信息存放在session中，其他信息如果需要保存，可以存放咋cookie中 6、session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息 7、session中保存的是对象，cookie中保存的是字符串 8、session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相访问不到的 web Storage和cookieWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要自己封装setCookie，getCookie但是cookie不可或缺，cookie的作用是与服务器进行交互，作为http规范的一部分，而web Storage仅仅是为了在本地“存储”数据而生，sessionStorage、localStorage、cookie的作用都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍在，关闭窗口后sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的 Web Storage带来的好处1、减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递2、快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以即使获得，再加上网页本身也有缓存，因此整个页面和数据都在本地的话，可以立即显示3、临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便 浏览器本地存储与服务端存储的区别其实数据既可以在浏览器本地存储，也可以在服务器端存储。浏览器可以保存一些数据，需要的时候直接从本地读取。sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。1、服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端2、服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些。浏览器只适合存储一般数据 sessionStorage、localStorage和cookie的区别共同点：都是保存在浏览器端、且同源区别：1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会把数据发送给服务器，仅在本地保存。cookie数据还有路径的概念，可以限制cookie只属于某个路径下2、存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大3、数据有效期不同sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭4、作用域不同sessionStorage不在不同的浏览器窗口共享，即使是同一个页面localStorage在所有同源窗口都是共享的cookie也是所有同源窗口中都是共享的5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者6、web Storage的api接口使用更方便 ManifestManifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，当第一次打开时，浏览器会自动缓存相应的资源 特点离线浏览：当网络断开时，可以继续访问页面访问速度快：将文件缓存到本地，不需要每次都从网络上请求稳定性：做了Manifest缓存，遇到突发网络故障或者服务器故障，继续访问本地缓存 用法创建一个和html同名的Manifest文件如：《html lang=”en” manifest=”index.manifest”》1、Manifest的引入可以是绝对路径也可以是相对路径，如果使用绝对路径，Manifest文件需要和站点挂在同一域名下2、Manifest文件可以保存为任意的扩展名，但mine-type必须是text/cache-manifest3、Manifest标签应该包含到你需要缓存资源的页面，当第一次打开该页面时，浏览器会解析该页面中的Manifest，并缓存里面列举的资源，同时该页面也会自动被浏览器缓存，即使该页面没有在Manifest中列出 内容分为三段：CACHE、NETWORK、FALLBACK，其中NETWORK和FALLBACK为可选项1、第一行为CACHE MANIFEST为固定格式，必须写在前面2、CACHE（必须）标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。这里列举出来的文件，当第一次加载下来时，会被浏览器还存在本地。3、NETWORK这部分是要绕过缓存直接读取文件，可以使用*。使用*时表示除了CACHE指定文件外其他所有页面都需要联网访问4、FALLBACK（可选）当资源无法访问时，浏览器使用后备资源去替代。第二个表示后备页面。两个URL都必须使用相对路径并且与清单文件同源。可以使用通配符","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"CDN相关","slug":"CDN相关","date":"2018-04-27T07:32:00.000Z","updated":"2018-04-29T14:42:38.000Z","comments":true,"path":"2018/04/27/CDN相关/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/CDN相关/","excerpt":"","text":"CDN访问流程1、用户向浏览器输入xxx.com这个域名，浏览器第一次发现本地没有DNS缓存，则向网站的DNS服务器请求2、网站的DNS域名解析器设置了CNAME，指向了xxxcdn.com，请求指向了CDN网络中的智能DNS负载均衡系统3、智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户4、用户向该IP节点（CDN服务器）发出请求5、由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容6、请求结果发给用户 CDN原理CDN网络是在用户和服务器之间增加Cache层，将用户的请求引导到Cache上获得源服务器的数据主要是通过接管DNS实现 1、当用户访问加入CDN服务的网站时，域名解析请求将最终交给全局负载均衡DNS进行处理。2、全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。3、同时，还与分布在世界各地的所有CDN节点保持通信，搜集各节点的通信状态，确保不将用户的请求分配到不可用的CDN节点上，实际上是通过DNS做全局负载均衡4、每个CDN节点由两部分组成：负载均衡设备、高速缓存服务器 负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率负载均衡设备还负责收集节点与周围环境的信息，保持与负载DNS的通信，实现整个系统的负载均衡。CDN的管理系统是整个系统能够正常运转的保证。不仅能对系统中的各个子系统和设备进行实时监控，对各种故障产生相应的警告，还可以实时检测到系统中总的流量和各个节点的流量，并保存在系统的数据库中，使网管人员能够方便的进行进一步分析 理论上，最简单的CDN网络有一个负责全局负载均衡的DNS和各节点的一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现就近访问。为了保证高可用性，需要监视各节点的流量、健康状态等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时工作，才需要负载均衡器，使Cache群协同工作。","categories":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}],"tags":[{"name":"计算机网络","slug":"net","permalink":"https://qiaoding18.github.io/tags/net/"}],"keywords":[{"name":"net","slug":"net","permalink":"https://qiaoding18.github.io/categories/net/"}]},{"title":"bind，call，apply","slug":"bind，call，apply","date":"2018-04-27T07:28:00.000Z","updated":"2018-04-27T07:34:42.000Z","comments":true,"path":"2018/04/27/bind，call，apply/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/bind，call，apply/","excerpt":"","text":"call()和apply()就是改变函数的执行上下文，也就是this值。他们两个是Function对象的方法，每个函数都能调用。 1234567let apply1 = (num1, num2) =&gt; &#123; return sum.apply(this, [num1, num2]);&#125;let call1 = (num1, num2) =&gt; &#123; return sum.call(this, num1, num2);&#125; 第一个参数是要指定的上下文，这里传了当前的this，就说明没改变sum函数的执行上下文。第二个参数是函数需要的参数，call需要一个个传，apply需要把这些参数放到数组中 bind是es5中的方法bind是新创建了一个函数，然后把它的上下文绑定到bind()括号中的参数上，然后将它返回 所以，bind函数不会立即执行，而是返回一个改变了上下问的函数副本，而call和apply是直接执行函数 12345var button = document.getElementById(\"button\"), text = document.getElementById(\"text\");button.onclick = function() &#123; alert(this.id); // 弹出text&#125;.bind(text); 模拟bind123456789if(!function()&#123;&#125;.bind)&#123; Function.prototype.bind = function(context)&#123; var that = this; var args = Array.prototype.slice.call(arguments); return function()&#123; return that.apply(context, args.slice(1)); &#125; &#125;&#125; 首先，我们判断是否存在bind方法，然后，若不存在，向Function对象的原型中添加自定义的bind方法。this指向调用他的对象Array.prototype.slice.call(arguments)把arguments转换成真的数组后面用闭包，把参数给apply","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Ajax","slug":"Ajax","date":"2018-04-27T06:31:00.000Z","updated":"2018-04-27T07:31:00.000Z","comments":true,"path":"2018/04/27/Ajax/","link":"","permalink":"https://qiaoding18.github.io/2018/04/27/Ajax/","excerpt":"","text":"Ajax原理及实现原理：通过xhr对象向服务器发出异步请求，从服务器获取数据，实现页面的局部刷新实现步骤：1、创建xhr对象2、设置服务器的连接信息xhr.opn(请求方式，url，异步还是同步)xhr.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);3、注册回调函数。onreadystatechange是发生变化执行xhr.onreadystatechange=callback;4、发送数据xhr.send();5、获取相应数据 JSON.parse(xhr.responseText); Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 Ajax和jsonp首先在客户端注册一个callback, 然后把callback的名字传给服务器。此时，服务器先生成 json 数据。然后将这个callback参数作为函数名来包裹住JSON数据，返回给客户端。客户端浏览器，动态执行回调函数，将返回的数据作为参数，传入到了客户端预先定义好的 callback 函数里.","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2018-03-21T07:48:00.000Z","updated":"2018-04-29T09:36:58.000Z","comments":true,"path":"2018/03/21/Flex布局/","link":"","permalink":"https://qiaoding18.github.io/2018/03/21/Flex布局/","excerpt":"","text":"基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。四个值：1、row（默认值）：主轴为水平方向，起点在左端。2、row-reverse：主轴为水平方向，起点在右端。3、column：主轴为垂直方向，起点在上沿。4、column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。三个值：（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。flex-flow: \\ || \\; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。五个值：1、flex-start（默认值）：左对齐2、flex-end：右对齐3、center： 居中4、space-between：两端对齐，项目之间的间隔都相等。5、space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items属性align-items属性定义项目在交叉轴上如何对齐。五个值：1、flex-start：交叉轴的起点对齐。2、flex-end：交叉轴的终点对齐。3、center：交叉轴的中点对齐。4、baseline: 项目的第一行文字的基线对齐。5、stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。六个值：1、flex-start：与交叉轴的起点对齐。2、flex-end：与交叉轴的终点对齐。3、center：与交叉轴的中点对齐。4、space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。5、space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。6、stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。orderflex-growflex-shrinkflex-basisflexalign-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"JS模块规范（AMD CMD）","slug":"JS模块规范（AMD-CMD）","date":"2018-02-27T08:33:00.000Z","updated":"2018-04-29T14:41:00.000Z","comments":true,"path":"2018/02/27/JS模块规范（AMD-CMD）/","link":"","permalink":"https://qiaoding18.github.io/2018/02/27/JS模块规范（AMD-CMD）/","excerpt":"","text":"CommonJSNode采用的是CommonJS，同步加载模块1234567var clock = require('clock.js');clock.start();// 导入const moduleA = require('./moduleA');// 导出module.exports = moduleA.someFunc; 这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快。但是如果在客户端，加载模块的时候有可能出现“假死”状况。比如上面的例子中clock的调用必须等待clock.js请求成功，加载完毕。那么，能不能异步加载模块呢？ AMDAMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行123456789101112require([module], callback);require(['clock.js'],function(clock)&#123; clock.start();&#125;);// 定义一个模块define('module', ['dep'], function(dep) &#123; return exports;&#125;);// 导入和使用require(['module'], function(module) &#123;&#125;); AMD虽然实现了异步加载，但是开始就把所有依赖写出来是不符合书写的逻辑顺序的，能不能像commonJS那样用的时候再require，而且还支持异步加载后再执行呢？AMD 的缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 CMDCMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：1234define(function(require, exports, module) &#123; var clock = require('clock.js'); clock.start();&#125;); AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]},{"title":"React和Vue对比","slug":"React和Vue对比","date":"2018-01-17T08:36:00.000Z","updated":"2018-04-29T09:37:02.000Z","comments":true,"path":"2018/01/17/React和Vue对比/","link":"","permalink":"https://qiaoding18.github.io/2018/01/17/React和Vue对比/","excerpt":"","text":"相同部分1、数据驱动视图，提供响应式的视图组件2、都有虚拟DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范3、都支持服务端渲染4、都有native解决方案 rn weex 不同1、社区：React比Vue还是要大2、开发模式：React本身是严格的view层，MVC模式 Vue是MVVM模式的一种方式实现3、数据绑定：Vue借鉴了angular，采用双向数据绑定的方式 React采取单向数据流的方式4、数据渲染：对于大规模数据渲染，React要高于Vue一些 对于较小的轻量级的，Vue确实更高效5、数据更新：Vue采取依赖追踪，默认是优化状态：按需更新 React手动添加shouldComponentUpdate，来避免多次重复渲染 总结Vue着重提高开发效率，让前端程序员更快速方便的开发应用React着重于变革开发思想，提升前端程序员编程的深度与创造力，让前端工程师成为真正的程序员而不是UI的构建者 关于优势Vue的优势1、模板和渲染函数的弹性选择2、简单的语法和项目配置3、更快的渲染速度和更小的体积 React的优势1、更适合大型应用和更好的可测试性2、Web端和移动端原生APP都有良好表现3、更大的生态系统，更多的支持和好用的工具 都具有的优势1、用虚拟DOM实现快速渲染2、轻量级3、响应式组件4、服务端渲染5、集成路由工具，打包工具，状态管理工具的难度低6、优秀的支持和社区","categories":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}],"tags":[{"name":"前端","slug":"web","permalink":"https://qiaoding18.github.io/tags/web/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://qiaoding18.github.io/categories/web/"}]}]}