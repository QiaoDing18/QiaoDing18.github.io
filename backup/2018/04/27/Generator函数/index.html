<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://qiaoding18.github.io/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=https://qiaoding18.github.io">
<meta name="author" content="乔丁">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>generator函数 - QiaoDing Blog</title>

<meta name="keywords" content="">

<meta name="description " content="">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="丁">丁</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span> 主页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span> 归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span> 标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">乔丁啊</h1>
        <h3 class="cover-siteTitle">一个前端小学生</h3>
        <p class="cover-siteDesc">在这写写博客啥了的</p>
        <div class="cover-sns">
            
            <div class="btn btn-github">
                <a href="https://github.com/QiaoDing18/" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>


        
            
                <li class="">
                    <a href="/categories/web" data-name="前端">前端</a>
                </li>
            
                <li class="">
                    <a href="/categories/net" data-name="计算机网络">计算机网络</a>
                </li>
            
                <li class="">
                    <a href="/categories/chat" data-name="闲聊">闲聊</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="搜索啦" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="输入要搜的内容啦"/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank">乔丁</a>
                    <span title="最后编辑于2018-04-27">2018-04-27</span>
                </p>
                <p>【前端小学生】</p>
            </div>
            <h2 class="post-title">Generator函数</h2>
            <div class="post-meta">
                本文总共7859个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>1、Generator函数是ES6提供的一种异步编程方案<br>2、从语法上，首先可以把它理解成一个状态机，封装了多个内部状态<br>3、Generator函数还是一个遍历器对象生成函数，返回遍历器对象<br>4、Generator函数有两个特征：1、function命令与函数名之间有一个星号；2、函数体内部使用yield语句定义不同的内部状态（“yield”在英语里的意思是“产出”）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>
<p>定义了一个Generator函数——helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello、world和return语句（结束执行）<br>在调用Generator函数后，<strong>该函数并不执行</strong>，<strong>返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象</strong>。<br>下一步必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或从函数上一次停下来的地方开始执行，直到遇到下一条yield语句（或return语句）为止。换言之，<strong>Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hw.next() <span class="comment">// &#123;value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123;value: 'world', done: false &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123;value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123;value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>ES6没有规定function关键字与函数名之间的星号必须在哪</p>
<h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><p>由于Generator函数返回的遍历器对象只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。<br>遍历器对象的next方法的运行逻辑如下：</p>
<blockquote>
<p>1、遇到yield语句就暂停执行后面的操作，并将紧跟在yield后的表达式的值作为返回的对象的value属性值<br>2、下一次调用next方法时才会继续执行，直到遇到下一个yield语句。<br>3、如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值作为返回的对象的value属性值。<br>4、如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
</blockquote>
<p>要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JS提供了手动的“惰性求值”的语法功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">123</span>+<span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，yield后面的表达式123+456不会立即求值，只会在next方法将指针移到这一语句时才求值</p>
<p>Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'执行了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	generator.next();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果f只是普通函数，在为变量generator赋值时就会执行。但是函数f是一个Generator函数，于是就变成只有调用next方法时才会执行。<br>要注意yield语句不能再普通函数中，yield语句在表达式中，必须放在括号里</p>
<h2 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h2><p>next方法可以携带一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; <span class="literal">true</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">		<span class="keyword">if</span>(reset) &#123;i = <span class="number">-1</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line">g.next() <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>定义了一个可以无限循环的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset就会被重置为这个参数，因而i会等于-1，下一轮循环就从-1开始递增。</p>
<p>Generator函数从暂停到恢复运行，其上下文状态是不变的。通过next方法的参数就有办法在Generator函数开始运行后继续向函数提内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">var</span> z = <span class="keyword">yield</span>( y / <span class="number">3</span> );</span><br><span class="line">	<span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next()<span class="comment">//Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next()<span class="comment">//Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next()<span class="comment">//Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next()<span class="comment">//Object&#123;value:6, done:false&#125;</span></span><br><span class="line">b.next(<span class="number">12</span>)<span class="comment">//Object&#123;value:8, done:false&#125;</span></span><br><span class="line">b.next(<span class="number">13</span>)<span class="comment">//Object&#123;value:42, done:false&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果next中没有参数，yield就返回undefined。所以在a第二次调next是y=2*undefined，所以结果为NaN。<br>在实例b中，第一次yield返回6。第二次传入12，所以第二次返回的值为2*12再除以3，所以结果为8.第三次同理<br>next参数就是上一条yield的返回值，所以第一次yield时不能带有参数。V8引擎会忽略第一次next时的参数，只从第二次使用next方法开始参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。如果想要第一次next带有参数，需要在Generator函数外再包一层。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapper</span>(<span class="params">generatorFunction</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> generatorObject = generatorFunction(...args);</span><br><span class="line">		generatorObject.next();</span><br><span class="line">		<span class="keyword">return</span> generatorObject;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapped = wrapper(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'First input: $&#123;yield&#125;'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">wrapped().next(<span class="string">'hello!'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果Generator函数不用wrapper先包一层，是无法第一次调用next方法就输入参数的。</p>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p><strong>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> foo()&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br></pre></td></tr></table></figure></p>
<p>for…of遇到done属性为true就会终止，且不包含该返回对象。所以return的6就不包括在for…of中</p>
<h2 id="Generator与协程"><a href="#Generator与协程" class="headerlink" title="Generator与协程"></a>Generator与协程</h2><p>协程是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程可以用单线程实现，也可以用多线程实现；前者是一种特殊的子线程，后者是一种特殊的线程。</p>
<h4 id="协程与子例程的差异"><a href="#协程与子例程的差异" class="headerlink" title="协程与子例程的差异"></a>协程与子例程的差异</h4><p>传统的“子例程”采用堆栈式“先进后出”的概念实现，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程可以并行执行，但只有一个线程处于正在运行状态，其他线程都处于暂停态，线程之间可以交换执行权。也就是说，一个线程执行到一半，可以暂停执行，将执行权交给另一个线程，等到稍后回收执行权时再恢复执行。这种可以并行执行，将执行权交给另一个线程，等到稍后收回执行权时再恢复执行。这种可以并行执行、交换执行权的线程，就成为协程。<br>从实现上看，在内存中子例程只使用一个栈，而协程是同时存在多个栈，但只有一个栈是在运行态。也就是说，协程是以多占用内存为代价实现多任务的并行运行。</p>
<h4 id="协程与普通线程的差异"><a href="#协程与普通线程的差异" class="headerlink" title="协程与普通线程的差异"></a>协程与普通线程的差异</h4><p>不难看出，协程适用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己执行的上下文，可以分享全局变量。他们不同之处在于，同一时间可以有多个线程是抢占式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。<br>ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误时可以找到原始的调用栈，不至于像异步操作的回调函数那样，一旦出错原始的调用栈早已结束。<br>Generator函数是ES6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”，意思是只有Generator函数的调用者才能将程序的执行权还给Generator函数。如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。<br>如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</p>
<h4 id="1、异步操作的同步化表达"><a href="#1、异步操作的同步化表达" class="headerlink" title="1、异步操作的同步化表达"></a>1、异步操作的同步化表达</h4><p>Generator函数的暂停执行效果，意味着可以把异步操作卸载yield语句里面，等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用于<strong>处理异步操作，改写回调函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	showLoadingScreen();</span><br><span class="line">	<span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">	hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">//加载UI</span></span><br><span class="line">loader.next();</span><br><span class="line"><span class="comment">//卸载UI</span></span><br><span class="line">loader.next();</span><br></pre></td></tr></table></figure></p>
<p>上面的代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，<strong>则会显示加载界面，并且异步加载数据</strong>。等到数据加载完成，再一次使用next方法，则会隐藏加载界面。可以看到，这种写法的好处是所有加载界面的逻辑都被封装在一个函数中，按部就班非常清晰。</p>
<p>Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://xxoo"</span>);</span><br><span class="line">	<span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">	<span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">	makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">		it.next(response);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure></p>
<p>上面的main函数就是通过AJAX操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法一模一样。注意，makeAjaxCall函数中的next方法必须加上response参数，因为yield语句构成的表达式本身是没有值的，总是等于undefined。</p>
<p>通过Generator实现的逐行读取文本文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> file = <span class="keyword">new</span> FileReader(<span class="string">"numbers.txt"</span>);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!file.eof)&#123;</span><br><span class="line">			<span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.readLine(), <span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		file.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码可以使用yield手动逐行读取文件</p>
<h4 id="2、控制流管理"><a href="#2、控制流管理" class="headerlink" title="2、控制流管理"></a>2、控制流管理</h4><p>如果有一个多步操作非常耗时，采用回调函数可能会写成这样。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span>(<span class="params">value1</span>)</span>&#123;</span><br><span class="line">	step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>)</span>&#123;</span><br><span class="line">		step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>)</span>&#123;</span><br><span class="line">			step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// Do something with value4</span></span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>采用Promise改写上面的代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Q.fcall(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value4</span>)</span>&#123;</span><br><span class="line">  		<span class="comment">//Do something with value4</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  		<span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure></p>
<p>上面代码把回调函数改成了直线执行的形式，但是加入了大量Promise的语法<br>Generator函数可以进一步改善代码运行流程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">longRunningTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = <span class="keyword">yield</span> step1();</span><br><span class="line">		<span class="keyword">var</span> value2 = <span class="keyword">yield</span> step2(value1);</span><br><span class="line">		<span class="keyword">var</span> value3 = <span class="keyword">yield</span> step2(value2);</span><br><span class="line">		<span class="keyword">var</span> value4 = <span class="keyword">yield</span> step2(value3);</span><br><span class="line">		<span class="comment">// do something with value4</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">		<span class="comment">// handle any err</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后使用一个函数按次序自动执行所有步骤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scheduler(longRunningTask());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> taskObj = task.next(task.value);</span><br><span class="line">		<span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">		<span class="keyword">if</span>(!taskObj.done)&#123;</span><br><span class="line">			task.value = taskObj.value</span><br><span class="line">			scheduler(task);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>yield语句是同步运行，不是异步运行（否则失去取代回调函数的设计目的）<br>多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有当任务A和任务B都执行完时才能执行C），可以采用数组的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parallelDownloads</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> [ text1, text2 ] = <span class="keyword">yield</span> [</span><br><span class="line">		taskA();</span><br><span class="line">		taskB();</span><br><span class="line">	];</span><br><span class="line">	<span class="built_in">console</span>.log(text1, text2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，yield语句的参数是一个数组，成员就是两个任务——taskA和taskB，只有等这两个任务都完成，才会接着执行下面的语句</p>
<h4 id="3、部署Iterator接口"><a href="#3、部署Iterator接口" class="headerlink" title="3、部署Iterator接口"></a>3、部署Iterator接口</h4><p>利用Generator函数可以在任意对象上部署Iterator接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;keys.length; i++)&#123;</span><br><span class="line">		<span class="keyword">let</span> key = key[i];</span><br><span class="line">		<span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj))&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 3  bar 7</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，myObj是一个普通对象，通过iterEntries函数就有了Iterator接口。也就是说，可以在任意对象上部署next方法。</p>
<h4 id="4、作为数据结构"><a href="#4、作为数据结构" class="headerlink" title="4、作为数据结构"></a>4、作为数据结构</h4><p>Generator可以看作数据结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式提供类似数组的接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">doStuff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'xx.txt'</span>);</span><br><span class="line">	<span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'oo.txt'</span>);</span><br><span class="line">	<span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'zz.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码一次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样处理这三个返回的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(task <span class="keyword">of</span> doStuff())&#123;</span><br><span class="line">	<span class="comment">//task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Generator使得数据或者操作具备了类似数组的接口</p>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/web/">前端</a>
            
        </div>
        
    </article>
    
    <p>本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！么么哒~</p>
    
    
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >帮助中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="http://www.tjoe18.cn/join/" title="个人链接">个人链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="https://xiyoumobile.com/" title="3G实验室">3G实验室</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 QiaoDing
        </p>
        

    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '06/21/1997',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
